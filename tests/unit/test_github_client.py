# Generated By: Cursor (Claude Sonnet 4.5)
"""Tests for GitHubClient class."""

import pytest
from datetime import datetime, timezone, timedelta

import gh_pr_metrics


class TestGitHubClient:
    """Test GitHubClient class functionality."""

    def test_initialization(self):
        """Test GitHubClient initializes with token."""
        client = gh_pr_metrics.GitHubClient("test_token")
        assert client._token == "test_token"

    def test_initialization_without_token(self):
        """Test GitHubClient initializes without token."""
        client = gh_pr_metrics.GitHubClient()
        assert client._token is None

    def test_make_request_success(self, requests_mock):
        """Test successful API request."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(url, json={"name": "repo"})

        client = gh_pr_metrics.GitHubClient()
        result = client.make_request(url)

        assert result["name"] == "repo"

    def test_make_request_with_token(self, requests_mock):
        """Test API request includes Authorization header when token provided."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(url, json={"name": "repo"})

        client = gh_pr_metrics.GitHubClient("test_token")
        client.make_request(url)

        assert "Authorization" in requests_mock.last_request.headers
        assert requests_mock.last_request.headers["Authorization"] == "Bearer test_token"

    def test_make_request_updates_quota(self, requests_mock):
        """Test that make_request updates quota_manager from headers."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(
            url,
            json={"name": "repo"},
            headers={
                "X-RateLimit-Remaining": "4999",
                "X-RateLimit-Limit": "5000",
                "X-RateLimit-Reset": "1699999999",
            },
        )

        # Create client with quota_manager
        client = gh_pr_metrics.GitHubClient(quota_manager=gh_pr_metrics.quota_manager)
        client.make_request(url)

        remaining, limit, reset = gh_pr_metrics.quota_manager.get_current_quota()
        assert remaining == 4999
        assert limit == 5000
        assert reset == 1699999999

    def test_make_request_rate_limit_error(self, requests_mock):
        """Test handling of rate limit errors."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(
            url,
            status_code=403,
            headers={
                "X-RateLimit-Remaining": "0",
                "X-RateLimit-Limit": "60",
                "X-RateLimit-Reset": "1699999999",
            },
        )

        client = gh_pr_metrics.GitHubClient()
        with pytest.raises(gh_pr_metrics.GitHubAPIError, match="rate limit exceeded"):
            client.make_request(url)

    def test_make_request_404_error(self, requests_mock):
        """Test handling of 404 errors."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(url, status_code=404)

        client = gh_pr_metrics.GitHubClient()
        with pytest.raises(gh_pr_metrics.GitHubAPIError, match="not found"):
            client.make_request(url)

    def test_fetch_all_prs_success(self, requests_mock):
        """Test fetching all PRs in range."""
        url = "https://api.github.com/repos/owner/repo/pulls"
        now = datetime.now(timezone.utc)
        start_date = now - timedelta(days=7)
        end_date = now

        # API returns descending (newest first), but function returns ascending
        prs_data = [
            {
                "number": 2,
                "updated_at": (start_date + timedelta(days=2)).isoformat(),
                "title": "PR 2",
            },
            {
                "number": 1,
                "updated_at": (start_date + timedelta(days=1)).isoformat(),
                "title": "PR 1",
            },
        ]
        requests_mock.get(url, json=prs_data)

        client = gh_pr_metrics.GitHubClient()
        result = client.fetch_all_prs("owner", "repo", start_date, end_date)

        # Function returns PRs in ascending order (oldest first)
        assert len(result) == 2
        assert result[0]["number"] == 1  # Oldest
        assert result[1]["number"] == 2  # Newest

    def test_list_repos_org(self, requests_mock):
        """Test listing repos for an organization."""
        url = "https://api.github.com/orgs/testowner/repos"
        requests_mock.get(
            url,
            json=[{"name": "repo1"}, {"name": "repo2"}, {"name": "repo3"}],
        )

        client = gh_pr_metrics.GitHubClient()
        repos = client.list_repos("testowner")

        assert repos == ["repo1", "repo2", "repo3"]

    def test_validate_repo_access_success(self, requests_mock):
        """Test successful repo access validation."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(url, json={"name": "repo"})

        client = gh_pr_metrics.GitHubClient()
        result = client.validate_repo_access("owner", "repo")

        assert result is True

    def test_validate_repo_access_failure(self, requests_mock):
        """Test failed repo access validation."""
        url = "https://api.github.com/repos/owner/repo"
        requests_mock.get(url, status_code=404)

        client = gh_pr_metrics.GitHubClient()
        result = client.validate_repo_access("owner", "repo")

        assert result is False

    def test_fetch_timeline_events(self, requests_mock):
        """Test fetching timeline events."""
        url = "https://api.github.com/repos/owner/repo/issues/123/events"
        events_data = [
            {"event": "ready_for_review", "created_at": "2024-01-01T00:00:00Z"},
        ]
        requests_mock.get(url, json=events_data)

        client = gh_pr_metrics.GitHubClient()
        events = client.fetch_timeline_events("owner", "repo", 123)

        assert len(events) == 1
        assert events[0]["event"] == "ready_for_review"

    def test_fetch_issue_comments(self, requests_mock):
        """Test fetching issue comments."""
        url = "https://api.github.com/repos/owner/repo/issues/123/comments"
        comments_data = [{"id": 1, "body": "Comment 1"}]
        requests_mock.get(url, json=comments_data)

        client = gh_pr_metrics.GitHubClient()
        comments = client.fetch_issue_comments(url)

        assert len(comments) == 1
        assert comments[0]["body"] == "Comment 1"

    def test_fetch_review_comments(self, requests_mock):
        """Test fetching review comments."""
        url = "https://api.github.com/repos/owner/repo/pulls/123/comments"
        comments_data = [{"id": 1, "body": "Review comment"}]
        requests_mock.get(url, json=comments_data)

        client = gh_pr_metrics.GitHubClient()
        comments = client.fetch_review_comments(url)

        assert len(comments) == 1
        assert comments[0]["body"] == "Review comment"

    def test_fetch_reviews(self, requests_mock):
        """Test fetching reviews."""
        url = "https://api.github.com/repos/owner/repo/pulls/123/reviews"
        reviews_data = [{"id": 1, "state": "APPROVED"}]
        requests_mock.get(url, json=reviews_data)

        client = gh_pr_metrics.GitHubClient()
        reviews = client.fetch_reviews("owner", "repo", 123)

        assert len(reviews) == 1
        assert reviews[0]["state"] == "APPROVED"

    def test_fetch_all_prs_stops_at_start_date(self, requests_mock):
        """Test that fetch_all_prs stops when hitting start_date."""
        start_date = datetime(2025, 8, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2025, 11, 25, 0, 0, 0, tzinfo=timezone.utc)

        # Mock response with PRs descending: newest first, stops at start_date
        requests_mock.get(
            "https://api.github.com/repos/owner/repo/pulls",
            json=[
                {
                    "number": 949,
                    "title": "Newer PR",
                    "updated_at": "2025-09-01T00:00:00Z",  # In range
                },
                {
                    "number": 818,
                    "title": "Older PR in range",
                    "updated_at": "2025-08-15T00:00:00Z",  # In range
                },
                {
                    "number": 200,
                    "title": "Too old",
                    "updated_at": "2025-07-20T00:00:00Z",  # Before start_date - STOP
                },
                {
                    "number": 100,
                    "title": "Even older",
                    "updated_at": "2025-07-15T00:00:00Z",  # Shouldn't process this
                },
            ],
            headers={"Link": ""},
        )

        client = gh_pr_metrics.GitHubClient(
            "test_token", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )
        prs = client.fetch_all_prs("owner", "repo", start_date, end_date)

        # Should return 2 PRs in ascending order (oldest first) and stop at PR 200
        assert len(prs) == 2
        assert prs[0]["number"] == 818  # Oldest in range
        assert prs[1]["number"] == 949  # Newest in range

    def test_fetch_all_prs_skips_prs_after_end_date(self, requests_mock):
        """Test that fetch_all_prs skips PRs after end_date."""
        start_date = datetime(2025, 8, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2025, 10, 1, 0, 0, 0, tzinfo=timezone.utc)

        # Mock response with PRs descending: after end, in range, before start
        requests_mock.get(
            "https://api.github.com/repos/owner/repo/pulls",
            json=[
                {
                    "number": 400,
                    "title": "Too new",
                    "updated_at": "2025-11-01T00:00:00Z",  # After end_date - skip
                },
                {
                    "number": 300,
                    "title": "Also too new",
                    "updated_at": "2025-10-15T00:00:00Z",  # After end_date - skip
                },
                {
                    "number": 200,
                    "title": "In range",
                    "updated_at": "2025-08-15T00:00:00Z",  # In range
                },
                {
                    "number": 100,
                    "title": "Too old",
                    "updated_at": "2025-07-15T00:00:00Z",  # Before start - STOP
                },
            ],
            headers={"Link": ""},
        )

        client = gh_pr_metrics.GitHubClient(
            "test_token", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )
        prs = client.fetch_all_prs("owner", "repo", start_date, end_date)

        # Should skip 400, 300, return 200, stop at 100
        assert len(prs) == 1
        assert prs[0]["number"] == 200

    def test_fetch_all_prs_with_multiple_pages(self, requests_mock):
        """
        Test that fetch_all_prs fetches multiple pages and returns them
        in ascending order.
        """
        start_date = datetime(2025, 8, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2025, 10, 1, 0, 0, 0, tzinfo=timezone.utc)

        # Single page with PRs, last one triggers stop
        requests_mock.get(
            "https://api.github.com/repos/owner/repo/pulls",
            json=[
                {
                    "number": 300,
                    "title": "Newer PR",
                    "updated_at": "2025-09-15T00:00:00Z",
                },
                {
                    "number": 200,
                    "title": "Middle PR",
                    "updated_at": "2025-08-15T00:00:00Z",
                },
                {
                    "number": 100,
                    "title": "Oldest in range",
                    "updated_at": "2025-08-05T00:00:00Z",
                },
                {
                    "number": 50,
                    "title": "Too old",
                    "updated_at": "2025-07-15T00:00:00Z",  # Before start - STOP
                },
            ],
            headers={"Link": ""},
        )

        client = gh_pr_metrics.GitHubClient(
            "test_token", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )
        prs = client.fetch_all_prs("owner", "repo", start_date, end_date)

        # Should return 3 PRs in ascending order (oldest first)
        assert len(prs) == 3
        assert prs[0]["number"] == 100  # Oldest
        assert prs[1]["number"] == 200
        assert prs[2]["number"] == 300  # Newest
