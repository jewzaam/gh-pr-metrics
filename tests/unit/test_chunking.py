# Generated By: Cursor (Claude Sonnet 4.5)
"""Tests for date range chunking and rate limit handling."""

from datetime import datetime, timedelta, timezone
import pytest

import gh_pr_metrics


@pytest.fixture(autouse=True)
def reset_quota_manager():
    """Reset quota manager before each test to prevent state pollution."""
    gh_pr_metrics.quota_manager._remaining = 0
    gh_pr_metrics.quota_manager._limit = 0
    gh_pr_metrics.quota_manager._reset = 0
    yield
    # Cleanup after test
    gh_pr_metrics.quota_manager._remaining = 0
    gh_pr_metrics.quota_manager._limit = 0
    gh_pr_metrics.quota_manager._reset = 0


class TestChunking:
    """Test date range chunking functionality."""

    def test_chunk_date_range_single_chunk(self):
        """Test chunking when range is within max_days."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 1, 15, 0, 0, 0, tzinfo=timezone.utc)  # 14 days

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        assert len(chunks) == 1
        assert chunks[0][0] == start
        assert chunks[0][1] == end

    def test_chunk_date_range_multiple_chunks(self):
        """Test chunking splits large ranges."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 3, 1, 0, 0, 0, tzinfo=timezone.utc)  # ~60 days

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # Should create at least 2 chunks
        assert len(chunks) >= 2

        # First chunk should start at start_date
        assert chunks[0][0] == start

        # Last chunk should end at end_date
        assert chunks[-1][1] == end

    def test_chunk_date_range_has_overlap(self):
        """Test that chunks overlap by 1 day to prevent data loss."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 3, 1, 0, 0, 0, tzinfo=timezone.utc)  # ~60 days

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # Verify overlap: second chunk should start before first chunk ends
        if len(chunks) > 1:
            first_end = chunks[0][1]
            second_start = chunks[1][0]

            # Second chunk starts 1 day before first ends (1 day overlap)
            overlap = first_end - second_start
            assert overlap == timedelta(days=1), f"Expected 1 day overlap, got {overlap.days} days"

    def test_chunk_date_range_covers_full_range(self):
        """Test that chunks cover the entire date range without gaps."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 12, 31, 0, 0, 0, tzinfo=timezone.utc)  # ~365 days

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # First chunk must start at original start
        assert chunks[0][0] == start

        # Last chunk must end at original end
        assert chunks[-1][1] == end

        # Verify no gaps between chunks (with overlap accounted for)
        for i in range(len(chunks) - 1):
            current_end = chunks[i][1]
            next_start = chunks[i + 1][0]

            # Next chunk should start no later than current chunk end
            # (it should actually start 1 day before due to overlap)
            assert next_start <= current_end, f"Gap detected between chunk {i} and {i+1}"

    def test_chunk_date_range_exact_multiple(self):
        """Test chunking when range is exact multiple of max_days."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 1, 31, 0, 0, 0, tzinfo=timezone.utc)  # Exactly 30 days

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # Should be single chunk (30 days fits in 30-day max)
        assert len(chunks) == 1

    def test_chunk_date_range_one_day_over(self):
        """Test chunking when range is just over max_days."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 2, 2, 0, 0, 0, tzinfo=timezone.utc)  # 32 days

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # Should create 2 chunks
        assert len(chunks) == 2

    def test_chunk_date_range_overlap_prevents_data_loss(self):
        """
        Test that overlap prevents data loss for PRs created at chunk boundaries.

        Scenario: PR created at 2024-01-31 23:59:59
        Chunk 1: 2024-01-01 to 2024-01-31
        Chunk 2: Should start at 2024-01-30 (1 day overlap) to catch boundary PRs
        """
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 3, 15, 0, 0, 0, tzinfo=timezone.utc)

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # Verify each chunk boundary has overlap
        for i in range(len(chunks) - 1):
            chunk1_end = chunks[i][1]
            chunk2_start = chunks[i + 1][0]

            # Chunk 2 should start 1 day before chunk 1 ends
            expected_overlap = chunk1_end - timedelta(days=1)
            assert chunk2_start == expected_overlap, (
                f"Chunk {i+1} should start at {expected_overlap}, " f"but starts at {chunk2_start}"
            )

    def test_chunk_date_range_year_long_range(self):
        """Test chunking a full year (365 days)."""
        start = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end = datetime(2024, 12, 31, 23, 59, 59, tzinfo=timezone.utc)

        chunks = gh_pr_metrics.chunk_date_range(start, end, max_days=30)

        # Should create ~13 chunks for 365 days with 30-day max and overlap
        assert len(chunks) >= 12
        assert len(chunks) <= 14  # Allow some variance

        # Verify coverage
        assert chunks[0][0] == start
        assert chunks[-1][1] == end


class TestRateLimitHandling:
    """Test rate limit estimation and checking."""

    def test_estimate_api_calls_for_prs(self):
        """Test API call estimation."""
        # 10 PRs should estimate 40 calls (4 per PR)
        estimated = gh_pr_metrics.estimate_api_calls_for_prs(10)
        assert estimated == 40

        # 0 PRs should estimate 0 calls
        estimated = gh_pr_metrics.estimate_api_calls_for_prs(0)
        assert estimated == 0

    def test_check_sufficient_rate_limit_enough_quota(self, requests_mock):
        """Test rate limit check when sufficient quota available."""
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={
                "resources": {
                    "core": {
                        "limit": 5000,
                        "remaining": 1000,
                        "reset": 1699999999,
                    }
                }
            },
        )

        # Should return True when we have enough
        sufficient, max_prs = gh_pr_metrics.check_sufficient_rate_limit(
            estimated_calls=400, repo_ctx="owner/repo"
        )
        assert sufficient is True
        assert max_prs > 0

    def test_check_sufficient_rate_limit_insufficient_quota(self):
        """Test rate limit check when insufficient quota."""
        # Set global quota (insufficient)
        gh_pr_metrics.quota_manager.__limit = 5000
        gh_pr_metrics.quota_manager.__remaining = 100  # Not enough for 400 + buffer

        # Should return (False, max_prs) when insufficient
        sufficient, max_prs = gh_pr_metrics.check_sufficient_rate_limit(
            estimated_calls=400, repo_ctx="owner/repo"
        )
        assert sufficient is False
        assert max_prs >= 0

    def test_check_sufficient_rate_limit_at_boundary(self):
        """Test rate limit check at exact boundary."""
        # With API_SAFETY_BUFFER=10, test at boundary
        gh_pr_metrics.quota_manager.__remaining = 410  # Exactly 400 + 10 buffer
        gh_pr_metrics.quota_manager.__limit = 5000

        # At boundary (remaining = estimated + buffer), should return (False, max_prs)
        sufficient, max_prs = gh_pr_metrics.check_sufficient_rate_limit(
            estimated_calls=400, repo_ctx="owner/repo"
        )
        # The condition is: remaining <= (estimated + buffer)
        # 410 <= 410 is True, so we should return False (insufficient)
        assert sufficient is False
        assert max_prs >= 0

    def test_check_sufficient_rate_limit_just_above_boundary(self):
        """Test rate limit check just above boundary with 5% reserve."""
        # With 5% reserve of 5000 = 250 (larger than API_SAFETY_BUFFER=10)
        gh_pr_metrics.quota_manager._limit = 5000
        gh_pr_metrics.quota_manager._remaining = 651  # One more than 400 + 250 buffer

        # Should return (True, max_prs) (remaining > estimated + buffer)
        sufficient, max_prs = gh_pr_metrics.check_sufficient_rate_limit(
            estimated_calls=400, repo_ctx="owner/repo"
        )
        assert sufficient is True
        assert max_prs > 0

    def test_check_sufficient_rate_limit_not_initialized(self, requests_mock):
        """Test rate limit check when quota not initialized (lazy initialization)."""
        # Reset global quota to uninitialized state
        gh_pr_metrics.quota_manager.__limit = 0
        gh_pr_metrics.quota_manager.__remaining = 0

        # Mock successful quota fetch
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={
                "resources": {
                    "core": {
                        "limit": 5000,
                        "remaining": 4500,
                        "reset": 1699999999,
                    }
                }
            },
        )

        # Should initialize quota and check properly
        sufficient, max_prs = gh_pr_metrics.check_sufficient_rate_limit(
            estimated_calls=400, repo_ctx="owner/repo"
        )
        assert sufficient is True  # Has enough after initialization
        assert max_prs > 0

    def test_get_rate_limit_info_success(self, requests_mock):
        """Test successful rate limit info retrieval."""
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={
                "resources": {
                    "core": {
                        "limit": 5000,
                        "remaining": 4500,
                        "reset": 1699999999,
                    }
                }
            },
        )

        info = gh_pr_metrics.get_rate_limit_info("test_token")
        assert info["limit"] == 5000
        assert info["remaining"] == 4500
        assert info["reset"] == 1699999999

    def test_get_rate_limit_info_error(self, requests_mock):
        """Test rate limit info retrieval on error."""
        requests_mock.get("https://api.github.com/rate_limit", status_code=500)

        info = gh_pr_metrics.get_rate_limit_info("test_token")
        assert info == {}


class TestChunkDeduplication:
    """Test that overlapping chunks don't reprocess the same PRs."""

    def test_duplicate_pr_filtering_in_chunks(self):
        """Test that duplicate PRs are filtered out in overlapping chunks."""
        # Create mock PRs
        pr_100 = {"number": 100, "created_at": "2024-01-30T12:00:00Z"}
        pr_101 = {"number": 101, "created_at": "2024-02-01T12:00:00Z"}

        # Simulate chunk 1 fetched PRs
        chunk1_prs = [pr_100]

        # Simulate chunk 2 fetched PRs (overlap includes pr_100 again)
        chunk2_prs = [pr_100, pr_101]

        # Track processed PRs
        processed_pr_numbers = set()

        # Process chunk 1
        new_prs_chunk1 = [pr for pr in chunk1_prs if pr["number"] not in processed_pr_numbers]
        for pr in new_prs_chunk1:
            processed_pr_numbers.add(pr["number"])

        # Should process 1 PR
        assert len(new_prs_chunk1) == 1
        assert new_prs_chunk1[0]["number"] == 100

        # Process chunk 2
        new_prs_chunk2 = [pr for pr in chunk2_prs if pr["number"] not in processed_pr_numbers]
        for pr in new_prs_chunk2:
            processed_pr_numbers.add(pr["number"])

        # Should only process PR 101 (PR 100 already processed)
        assert len(new_prs_chunk2) == 1
        assert new_prs_chunk2[0]["number"] == 101

        # Total processed should be 2 unique PRs
        assert len(processed_pr_numbers) == 2
        assert processed_pr_numbers == {100, 101}
