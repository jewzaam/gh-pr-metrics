#!/usr/bin/env python3
# Generated By: Cursor (Claude Sonnet 4.5)
"""
Configuration Management Module

Handles loading and validation of application configuration from YAML files.
"""

import yaml
from pathlib import Path
from typing import Dict, Any, List, Optional


# Constants (imported from main)
DEFAULT_WORKERS = 4
DEFAULT_RAW_DATA_DIR = "data/raw"


class ConditionalBotConfig:
    """Configuration for conditional AI bot detection."""

    def __init__(self, name: str, content_patterns: List[str], match_any: bool = True):
        self.name = name
        self.content_patterns = content_patterns
        self.match_any = match_any

    def matches_content(self, comment_body: str) -> bool:
        """Check if comment body matches AI patterns using regex."""
        import re

        if not comment_body:
            return False

        if self.match_any:
            # Any pattern match = AI
            return any(re.search(pattern, comment_body) for pattern in self.content_patterns)
        else:
            # All patterns required = AI
            return all(re.search(pattern, comment_body) for pattern in self.content_patterns)


class Config:
    """Application configuration loaded from YAML file."""

    def __init__(self, config_dict: Dict[str, Any]):
        """Initialize config from parsed YAML dict."""
        # AI bot detection
        ai_bots = config_dict.get("ai_bots", {})
        self.always_ai_bots: List[str] = ai_bots.get("always", [])
        self.conditional_bots: List[ConditionalBotConfig] = []

        for bot_config in ai_bots.get("conditional", []):
            self.conditional_bots.append(
                ConditionalBotConfig(
                    name=bot_config["name"],
                    content_patterns=bot_config.get("content_patterns", []),
                    match_any=bot_config.get("match_any", True),
                )
            )

        # Processing settings
        self.workers: int = config_dict.get("workers", DEFAULT_WORKERS)
        self.output_pattern: Optional[str] = config_dict.get("output_pattern")
        self.log_file: str = config_dict.get("log_file", "gh-pr-metrics.log")
        self.raw_data_dir: str = config_dict.get("raw_data_dir", DEFAULT_RAW_DATA_DIR)

    def is_ai_bot(self, login: str, comment_body: str = "") -> bool:
        """
        Determine if a login/comment is from an AI bot.

        Args:
            login: The GitHub login name
            comment_body: The comment text (optional, for conditional detection)

        Returns:
            True if identified as AI bot, False otherwise
        """
        # Check always-AI bots with regex
        import re

        for pattern in self.always_ai_bots:
            if re.match(pattern, login):
                return True

        # Check conditional bots with regex
        for bot_config in self.conditional_bots:
            if re.match(bot_config.name, login):
                return bot_config.matches_content(comment_body)

        return False


def load_config(config_path: str) -> Config:
    """
    Load and validate configuration from YAML file.

    Args:
        config_path: Path to configuration file

    Returns:
        Validated Config object (uses defaults if file missing or empty)

    Raises:
        ValueError: If config YAML is invalid or output_pattern lacks placeholders
    """
    config_file = Path(config_path)

    # Missing config file = use defaults
    if not config_file.exists():
        return Config({})

    try:
        with open(config_file, "r", encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)

        # Empty config file = use defaults
        if config_dict is None:
            return Config({})

        # Validate output_pattern has placeholders if set
        output_pattern = config_dict.get("output_pattern")
        if output_pattern and "{owner}" not in output_pattern and "{repo}" not in output_pattern:
            raise ValueError(
                f"Invalid output_pattern '{output_pattern}': "
                "must contain {{owner}} and/or {{repo}} placeholders"
            )

        return Config(config_dict)

    except yaml.YAMLError as e:
        raise ValueError(f"Invalid YAML in configuration file: {e}")
    except KeyError as e:
        raise ValueError(f"Missing required configuration key: {e}")
