#!/usr/bin/env python3
# Generated By: Cursor (Claude Sonnet 4.5)
"""
State Management Module

Handles state file operations for tracking repository processing progress.
Thread-safe via locking decorators.
"""

import threading
import yaml
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, List, Optional


# Note: parse_timestamp will need to be imported from main module or utils
# For now, keeping as external dependency


def with_lock(func):
    """Decorator to synchronize access to StateManager methods using self._lock."""

    def wrapper(self, *args, **kwargs):
        with self._lock:
            return func(self, *args, **kwargs)

    return wrapper


class StateManager:
    """
    Manages state file for tracking repository processing progress.

    State file stores last update timestamp, CSV file path, and failed PRs per repository.
    Thread-safe via @with_lock decorator on all public methods.
    """

    def __init__(self, state_file_path: Path = None, logger=None):
        """Initialize state manager with path to state file and logger."""
        # Default state file path
        default_state_file = Path.home() / ".gh-pr-metrics-state.yaml"
        self._state_file = state_file_path or default_state_file
        self._logger = logger
        self._lock = threading.RLock()  # Reentrant lock for nested lock acquisitions

    @with_lock
    def load(self) -> Dict[str, Any]:
        """Load state file containing last update dates per repo. Thread-safe."""
        if not self._state_file.exists():
            return {}

        try:
            with open(self._state_file, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f) or {}
                return data
        except Exception as e:
            if self._logger:
                self._logger.warning("Failed to load state file %s: %s", self._state_file, e)
            return {}

    @with_lock
    def save(self, state: Dict[str, Any]) -> None:
        """Save state file with last update dates per repo. Thread-safe."""
        try:
            with open(self._state_file, "w", encoding="utf-8") as f:
                yaml.safe_dump(state, f, default_flow_style=False, sort_keys=True)

            if self._logger:
                self._logger.debug("Saved state file to %s", self._state_file)
        except Exception as e:
            if self._logger:
                self._logger.error("Failed to save state file %s: %s", self._state_file, e)
            raise

    def get_repo_remote_url(self, owner: str, repo: str) -> str:
        """
        Get repository remote URL key for state tracking.
        Uses format: https://github.com/owner/repo
        """
        return f"https://github.com/{owner}/{repo}"

    @with_lock
    def get_repo_state(self, owner: str, repo: str) -> Optional[Dict[str, Any]]:
        """
        Get state for a repository (timestamp, csv_file, failed_prs).
        Returns dict with keys, or None if not found.
        Raises ValueError if state is malformed. Thread-safe.
        """
        from gh_pr_metrics import parse_timestamp  # Import here to avoid circular dependency

        state = self.load()
        repo_key = self.get_repo_remote_url(owner, repo)

        if repo_key not in state:
            return None

        entry = state[repo_key]

        if not isinstance(entry, dict):
            raise ValueError(
                f"Invalid state format for {repo_key} in state file. "
                f"Expected dict with 'timestamp' and 'csv_file', got {type(entry).__name__}"
            )

        timestamp_str = entry.get("timestamp", "")
        csv_file = entry.get("csv_file")

        if not timestamp_str:
            # Allow missing timestamp for newly initialized repos
            return None

        if not csv_file:
            # csv_file is optional now (can be set by init or csv commands)
            csv_file = None

        try:
            timestamp = parse_timestamp(timestamp_str)
        except ValueError as e:
            raise ValueError(
                f"Invalid timestamp for {repo_key} in state file: {e}. "
                f"State file location: {self._state_file}"
            ) from e

        return {
            "timestamp": timestamp,
            "csv_file": csv_file,
            "failed_prs": entry.get("failed_prs", []),
        }

    @with_lock
    def update_repo(
        self, owner: str, repo: str, timestamp: datetime, csv_file: Optional[str]
    ) -> None:
        """Update state file with new last update date and optional csv file. Thread-safe."""
        state = self.load()
        repo_key = self.get_repo_remote_url(owner, repo)
        # Store as UTC timestamp without timezone component
        utc_timestamp = timestamp.astimezone(timezone.utc).replace(tzinfo=None)

        # Preserve existing fields (especially failed_prs)
        if repo_key not in state:
            state[repo_key] = {}
        elif not isinstance(state[repo_key], dict):
            if self._logger:
                self._logger.warning(
                    "Malformed state for %s: expected dict, got %s. Resetting to empty dict.",
                    repo_key,
                    type(state[repo_key]).__name__,
                )
            state[repo_key] = {}

        state[repo_key]["timestamp"] = utc_timestamp.isoformat()
        if csv_file is not None:
            state[repo_key]["csv_file"] = csv_file

        # Initialize failed_prs if not present
        if "failed_prs" not in state[repo_key]:
            state[repo_key]["failed_prs"] = []

        self.save(state)

    @with_lock
    def mark_pr_failed(self, owner: str, repo: str, pr_number: int) -> None:
        """Mark a PR as failed. Will be retried on next run. Thread-safe."""
        state = self.load()
        repo_key = self.get_repo_remote_url(owner, repo)

        if repo_key not in state:
            state[repo_key] = {}
        elif not isinstance(state[repo_key], dict):
            if self._logger:
                self._logger.warning(
                    "Malformed state for %s: expected dict, got %s.",
                    repo_key,
                    type(state[repo_key]).__name__,
                )
            state[repo_key] = {"timestamp": state[repo_key]}

        if "failed_prs" not in state[repo_key]:
            state[repo_key]["failed_prs"] = []

        if pr_number not in state[repo_key]["failed_prs"]:
            state[repo_key]["failed_prs"].append(pr_number)

        self.save(state)
        if self._logger:
            self._logger.warning("Marked PR #%d as failed for %s/%s", pr_number, owner, repo)

    @with_lock
    def mark_pr_succeeded(self, owner: str, repo: str, pr_number: int) -> None:
        """Remove a PR from failed list after successful fetch. Thread-safe."""
        state = self.load()
        repo_key = self.get_repo_remote_url(owner, repo)

        if repo_key in state and isinstance(state[repo_key], dict):
            failed_prs = state[repo_key].get("failed_prs", [])
            if pr_number in failed_prs:
                failed_prs.remove(pr_number)
                state[repo_key]["failed_prs"] = failed_prs
                self.save(state)
                if self._logger:
                    self._logger.info(
                        "Removed PR #%d from failed list for %s/%s", pr_number, owner, repo
                    )

    @with_lock
    def get_failed_prs(self, owner: str, repo: str) -> List[int]:
        """Get list of failed PR numbers for a repository. Thread-safe."""
        state = self.load()
        repo_key = self.get_repo_remote_url(owner, repo)

        if repo_key in state and isinstance(state[repo_key], dict):
            return state[repo_key].get("failed_prs", [])
        return []

    @with_lock
    def get_all_failed_prs_count(self) -> int:
        """Get total count of failed PRs across all repositories. Thread-safe."""
        state = self.load()
        total = 0
        for entry in state.values():
            if isinstance(entry, dict):
                total += len(entry.get("failed_prs", []))
        return total

    @with_lock
    def get_all_tracked_repos(self) -> List[Dict[str, Any]]:
        """
        Get all tracked repositories from state file.
        Returns list of dicts with 'url', 'owner', 'repo', 'timestamp', 'csv_file'.
        Thread-safe.
        """
        from gh_pr_metrics import parse_timestamp  # Import here to avoid circular dependency

        state = self.load()
        repos = []

        for repo_url, entry in state.items():
            # Parse URL to get owner/repo
            # Format: https://github.com/owner/repo
            try:
                parts = repo_url.rstrip("/").split("/")
                if len(parts) >= 2:
                    owner = parts[-2]
                    repo = parts[-1]

                    if isinstance(entry, dict):
                        timestamp = parse_timestamp(entry.get("timestamp", ""))
                        csv_file = entry.get("csv_file")
                    else:
                        if self._logger:
                            self._logger.warning("Skipping %s: invalid state format", repo_url)
                        continue

                    repos.append(
                        {
                            "url": repo_url,
                            "owner": owner,
                            "repo": repo,
                            "timestamp": timestamp,
                            "csv_file": csv_file,
                        }
                    )
            except Exception as e:
                if self._logger:
                    self._logger.warning("Failed to parse state entry for %s: %s", repo_url, e)
                continue

        return repos
