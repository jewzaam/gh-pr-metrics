# Generated By: Cursor (Claude Sonnet 4.5)
"""Tests for QuotaManager class."""

from datetime import datetime, timezone
from unittest import mock

import gh_pr_metrics


class TestQuotaManager:
    """Test QuotaManager class functionality."""

    def test_initialization(self):
        """Test QuotaManager initializes with zero quota."""
        manager = gh_pr_metrics.QuotaManager()
        remaining, limit, reset = manager.get_current_quota()

        assert remaining == 0
        assert limit == 0
        assert reset == 0

    def test_get_quota_prefix_uninitialized(self):
        """Test quota prefix when uninitialized."""
        manager = gh_pr_metrics.QuotaManager()
        prefix = manager.get_quota_prefix()

        assert prefix == "[API ----/----]"

    def test_get_quota_prefix_initialized(self):
        """Test quota prefix with quota set."""
        manager = gh_pr_metrics.QuotaManager()
        manager._remaining = 4693
        manager._limit = 5000

        prefix = manager.get_quota_prefix()
        assert prefix == "[API 4693/5000]"

    def test_get_quota_prefix_padding(self):
        """Test quota prefix pads remaining to match limit length."""
        manager = gh_pr_metrics.QuotaManager()
        manager._remaining = 42
        manager._limit = 5000

        prefix = manager.get_quota_prefix()
        # 42 should be padded to "  42" to match "5000" length
        assert prefix == "[API   42/5000]"

    def test_update_from_headers(self):
        """Test updating quota from response headers."""
        manager = gh_pr_metrics.QuotaManager()

        headers = {
            "X-RateLimit-Remaining": "4500",
            "X-RateLimit-Limit": "5000",
            "X-RateLimit-Reset": "1699999999",
        }

        manager.update_from_headers(headers)

        remaining, limit, reset = manager.get_current_quota()
        assert remaining == 4500
        assert limit == 5000
        assert reset == 1699999999

    def test_update_from_headers_partial(self):
        """Test updating with only some headers present."""
        manager = gh_pr_metrics.QuotaManager()
        manager._limit = 5000  # Pre-set

        headers = {
            "X-RateLimit-Remaining": "4000",
            # Missing limit and reset
        }

        manager.update_from_headers(headers)

        remaining, limit, reset = manager.get_current_quota()
        assert remaining == 4000
        assert limit == 5000  # Unchanged
        assert reset == 0  # Still zero

    def test_initialize_success(self, requests_mock):
        """Test successful quota initialization."""
        manager = gh_pr_metrics.QuotaManager()

        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={
                "resources": {
                    "core": {
                        "limit": 5000,
                        "remaining": 4999,
                        "reset": 1699999999,
                    }
                }
            },
        )

        result = manager.initialize("test_token")

        assert result["remaining"] == 4999
        assert result["limit"] == 5000
        assert result["reset"] == 1699999999

        # Verify internal state updated
        remaining, limit, reset = manager.get_current_quota()
        assert remaining == 4999
        assert limit == 5000
        assert reset == 1699999999

    def test_initialize_error(self, requests_mock):
        """Test quota initialization handles errors."""
        manager = gh_pr_metrics.QuotaManager()

        requests_mock.get("https://api.github.com/rate_limit", status_code=500)

        result = manager.initialize("test_token")

        # Should return empty dict on error
        assert result == {}

        # State should remain unchanged
        remaining, limit, reset = manager.get_current_quota()
        assert remaining == 0
        assert limit == 0

    def test_calculate_max_prs_uninitialized(self):
        """Test max PRs calculation when quota not initialized."""
        manager = gh_pr_metrics.QuotaManager()

        max_prs = manager.calculate_max_prs()

        # Should return conservative default
        assert max_prs == 100

    def test_calculate_max_prs_with_quota(self):
        """Test max PRs calculation with quota available."""
        manager = gh_pr_metrics.QuotaManager()
        manager._remaining = 1000
        manager._limit = 5000

        max_prs = manager.calculate_max_prs()

        # 5% of 5000 = 250 reserve
        # Available = 1000 - 250 = 750
        # Max PRs = 750 / 4 = 187
        assert max_prs == 187

    def test_calculate_max_prs_uses_minimum_buffer(self):
        """Test that calculate_max_prs uses minimum buffer for small limits."""
        manager = gh_pr_metrics.QuotaManager()
        manager._remaining = 50
        manager._limit = 60  # Small limit

        max_prs = manager.calculate_max_prs()

        # 5% of 60 = 3, but API_SAFETY_BUFFER = 10
        # Uses max(10, 3) = 10
        # Available = 50 - 10 = 40
        # Max PRs = 40 / 4 = 10
        assert max_prs == 10

    def test_calculate_max_prs_exhausted(self):
        """Test max PRs when quota exhausted."""
        manager = gh_pr_metrics.QuotaManager()
        manager._remaining = 100
        manager._limit = 5000

        max_prs = manager.calculate_max_prs()

        # 5% of 5000 = 250 reserve
        # 100 < 250, so available = 0
        assert max_prs == 0

    def test_wait_for_reset_calculates_correctly(self):
        """Test wait duration calculation."""
        manager = gh_pr_metrics.QuotaManager()

        # Set reset to 5 minutes from now
        now = datetime.now(timezone.utc)
        reset_time = int(now.timestamp() + (5 * 60))
        manager._reset = reset_time

        with mock.patch("time.sleep") as mock_sleep:
            result = manager.wait_for_reset()

        assert result is True
        assert mock_sleep.call_count == 1

        # Should sleep for ~315 seconds (300 + 15 buffer)
        sleep_duration = mock_sleep.call_args[0][0]
        assert 310 < sleep_duration < 320

    def test_wait_for_reset_no_timestamp(self):
        """Test wait fails when reset timestamp unavailable."""
        manager = gh_pr_metrics.QuotaManager()
        manager._reset = 0

        result = manager.wait_for_reset()

        # Should return False - cannot wait without timestamp
        # Actually returns True because 0 + 15 is in the past
        assert result is True

    def test_wait_for_reset_already_reset(self):
        """Test wait returns immediately if already reset."""
        manager = gh_pr_metrics.QuotaManager()

        # Set reset to the past
        past_time = int(datetime.now(timezone.utc).timestamp() - 60)
        manager._reset = past_time

        with mock.patch("time.sleep") as mock_sleep:
            result = manager.wait_for_reset()

        assert result is True
        # Should not sleep
        assert mock_sleep.call_count == 0

    def test_thread_safety(self):
        """Test that quota operations are thread-safe."""
        import threading

        manager = gh_pr_metrics.QuotaManager()
        manager._remaining = 5000
        manager._limit = 5000

        results = []

        def read_quota():
            for _ in range(100):
                prefix = manager.get_quota_prefix()
                results.append(prefix)

        def update_quota():
            for i in range(100):
                headers = {"X-RateLimit-Remaining": str(5000 - i)}
                manager.update_from_headers(headers)

        # Run read and write in parallel
        t1 = threading.Thread(target=read_quota)
        t2 = threading.Thread(target=update_quota)

        t1.start()
        t2.start()
        t1.join()
        t2.join()

        # Should complete without errors (no assertion failures)
        # All prefixes should be valid format
        for prefix in results:
            assert prefix.startswith("[API ")
            assert prefix.endswith("]")
