# Generated By: Cursor (Claude Sonnet 4.5)
"""
Unit tests for command classes with mocked dependencies.
"""

import argparse
from unittest import mock

from commands import InitCommand, FetchCommand, CsvCommand


class TestInitCommand:
    """Unit tests for InitCommand."""

    def test_init_single_repo_success(self, tmp_path):
        """Test initializing a single repository."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start="2024-01-01",
            output=str(tmp_path / "test.csv"),
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = InitCommand()

        # Mock setup to avoid real initialization
        with mock.patch.object(cmd, "setup"):
            # Mock dependencies
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_repo_state.return_value = None  # Not initialized yet
            cmd.config = mock.Mock()
            cmd.logger = mock.Mock()

            # Run command
            result = cmd.run(args)

            # Verify success
            assert result == 0
            cmd.state_manager.update_repo.assert_called_once()

    def test_init_all_repos_for_owner(self, tmp_path):
        """Test initializing all repos for an owner."""
        args = argparse.Namespace(
            owner="testowner",
            repo=None,
            start="2024-01-01",
            output=str(tmp_path / "test-{repo}.csv"),
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = InitCommand()

        with mock.patch.object(cmd, "setup"):
            # Mock dependencies
            cmd.github_client = mock.Mock()
            cmd.github_client.list_repos.return_value = [
                {"name": "repo1", "owner": {"login": "testowner"}},
                {"name": "repo2", "owner": {"login": "testowner"}},
            ]
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_repo_state.return_value = None  # Not initialized yet
            cmd.config = mock.Mock()
            cmd.logger = mock.Mock()

            # Run command
            result = cmd.run(args)

            # Verify success
            assert result == 0
            cmd.github_client.list_repos.assert_called_once_with("testowner")
            # Should call update_repo twice (once per repo)
            assert cmd.state_manager.update_repo.call_count == 2

    def test_init_invalid_start_date(self):
        """Test initializing with invalid start date."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start="invalid-date",
            output="test.csv",
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = InitCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.logger = mock.Mock()

            # Run command
            result = cmd.run(args)

            # Verify failure
            assert result == 1
            cmd.logger.error.assert_called()


class TestFetchCommand:
    """Unit tests for FetchCommand."""

    def test_fetch_basic_success(self, tmp_path):
        """Test basic fetch operation."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start="2024-01-01",
            end=None,
            update=False,
            all=False,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_fetch_repository", return_value=0) as mock_fetch:
                # Mock dependencies
                cmd.config = mock.Mock()
                cmd.config.raw_data_dir = str(tmp_path / "raw")
                cmd.logger = mock.Mock()

                # Run command
                result = cmd.run(args)

                # Verify success
                assert result == 0
                mock_fetch.assert_called_once()

    def test_fetch_missing_required_args(self):
        """Test fetch fails when required args missing."""
        args = argparse.Namespace(
            owner=None,
            repo="testrepo",
            start="2024-01-01",
            end=None,
            update=False,
            all=False,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.logger = mock.Mock()

            # Run command
            result = cmd.run(args)

            # Verify failure
            assert result == 1
            cmd.logger.error.assert_called()

    def test_fetch_all_repos(self):
        """Test fetching all tracked repos."""
        from datetime import datetime, timezone

        args = argparse.Namespace(
            owner=None,
            repo=None,
            start=None,
            end=None,
            update=False,
            all=True,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_fetch_repository", return_value=0):
                # Mock dependencies
                cmd.config = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_all_tracked_repos.return_value = [
                    {
                        "owner": "owner1",
                        "repo": "repo1",
                        "csv_file": "test1.csv",
                        "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                    },
                    {
                        "owner": "owner2",
                        "repo": "repo2",
                        "csv_file": "test2.csv",
                        "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                    },
                ]
                cmd.logger = mock.Mock()

                # Run command
                result = cmd.run(args)

                # Verify success
                assert result == 0

    def test_fetch_all_repos_no_tracked_repos(self):
        """Test fetch all when no repos are tracked."""
        args = argparse.Namespace(
            owner=None,
            repo=None,
            start=None,
            end=None,
            update=False,
            all=True,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_all_tracked_repos.return_value = []
            cmd.logger = mock.Mock()

            result = cmd.run(args)

            assert result == 1
            cmd.logger.error.assert_called()

    def test_fetch_all_repos_with_failure_and_wait(self):
        """Test fetch all continues with --wait flag on failure."""
        from datetime import datetime, timezone

        args = argparse.Namespace(
            owner=None,
            repo=None,
            start=None,
            end=None,
            update=False,
            all=True,
            pr=None,
            wait=True,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_fetch_repository", side_effect=[1, 0]) as mock_fetch:
                cmd.config = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_all_tracked_repos.return_value = [
                    {
                        "owner": "owner1",
                        "repo": "repo1",
                        "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                    },
                    {
                        "owner": "owner2",
                        "repo": "repo2",
                        "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                    },
                ]
                cmd.logger = mock.Mock()

                result = cmd.run(args)

                # Should continue and process both repos
                assert mock_fetch.call_count == 2
                assert result == 1  # But still return error

    def test_fetch_update_mode_success(self):
        """Test update mode fetches since last timestamp."""
        from datetime import datetime, timezone

        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start=None,
            end=None,
            update=True,
            all=False,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_fetch_repository", return_value=0) as mock_fetch:
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_repo_state.return_value = {
                    "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                }
                cmd.logger = mock.Mock()

                result = cmd.run(args)

                assert result == 0
                mock_fetch.assert_called_once()

    def test_fetch_update_mode_no_state(self):
        """Test update mode fails when no state found."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start=None,
            end=None,
            update=True,
            all=False,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_repo_state.return_value = None
            cmd.logger = mock.Mock()

            result = cmd.run(args)

            assert result == 1
            cmd.logger.error.assert_called()

    def test_fetch_single_pr_success(self):
        """Test fetching a single PR."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start=None,
            end=None,
            update=False,
            all=False,
            pr=123,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch("commands.fetch_command.PRFetcher") as mock_fetcher_class:
                with mock.patch.object(cmd, "_get_github_token", return_value="fake-token"):
                    mock_fetcher = mock.Mock()
                    mock_fetcher_class.return_value = mock_fetcher

                    cmd.github_client = mock.Mock()
                    cmd.github_client.make_request.return_value = {
                        "number": 123,
                        "title": "Test PR",
                    }
                    cmd.quota_manager = mock.Mock()
                    cmd.config = mock.Mock()
                    cmd.state_manager = mock.Mock()
                    cmd.logger = mock.Mock()

                    result = cmd.run(args)

                    assert result == 0
                    mock_fetcher.fetch_and_cache_pr.assert_called_once()

    def test_fetch_single_pr_failure(self):
        """Test single PR fetch handles errors."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start=None,
            end=None,
            update=False,
            all=False,
            pr=123,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.github_client = mock.Mock()
            cmd.github_client.make_request.side_effect = Exception("API error")
            cmd.logger = mock.Mock()

            result = cmd.run(args)

            assert result == 1
            cmd.logger.error.assert_called()

    def test_fetch_repository_with_prs(self, tmp_path):
        """Test _fetch_repository with PRs to fetch."""
        from datetime import datetime, timezone

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch("commands.fetch_command.PRFetcher") as mock_fetcher_class:
                with mock.patch.object(cmd, "_get_github_token", return_value="fake-token"):
                    mock_fetcher = mock.Mock()
                    mock_fetcher_class.return_value = mock_fetcher
                    mock_fetcher.fetch_pr_list.return_value = [
                        {"number": 1, "title": "PR 1"},
                        {"number": 2, "title": "PR 2"},
                    ]
                    mock_fetcher.fetch_and_cache_pr.return_value = None

                    cmd.github_client = mock.Mock()
                    cmd.quota_manager = mock.Mock()
                    cmd.quota_manager.check_sufficient.return_value = (True, 10)
                    cmd.config = mock.Mock()
                    cmd.state_manager = mock.Mock()
                    cmd.logger = mock.Mock()

                    result = cmd._fetch_repository(
                        "owner",
                        "repo",
                        datetime(2024, 1, 1, tzinfo=timezone.utc),
                        datetime(2024, 2, 1, tzinfo=timezone.utc),
                        2,
                    )

                    assert result == 0
                    assert mock_fetcher.fetch_and_cache_pr.call_count == 2

    def test_fetch_repository_no_prs(self):
        """Test _fetch_repository when no PRs found."""
        from datetime import datetime, timezone

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch("commands.fetch_command.PRFetcher") as mock_fetcher_class:
                with mock.patch.object(cmd, "_get_github_token", return_value="fake-token"):
                    mock_fetcher = mock.Mock()
                    mock_fetcher_class.return_value = mock_fetcher
                    mock_fetcher.fetch_pr_list.return_value = []

                    cmd.github_client = mock.Mock()
                    cmd.quota_manager = mock.Mock()
                    cmd.config = mock.Mock()
                    cmd.state_manager = mock.Mock()
                    cmd.logger = mock.Mock()

                    result = cmd._fetch_repository(
                        "owner",
                        "repo",
                        datetime(2024, 1, 1, tzinfo=timezone.utc),
                        datetime(2024, 2, 1, tzinfo=timezone.utc),
                        2,
                    )

                    assert result == 0
                    cmd.state_manager.update_repo.assert_called_once()

    def test_fetch_repository_insufficient_quota(self):
        """Test _fetch_repository fails with insufficient quota."""
        from datetime import datetime, timezone

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch("data.PRFetcher") as mock_fetcher_class:
                mock_fetcher = mock.Mock()
                mock_fetcher_class.return_value = mock_fetcher
                mock_fetcher.fetch_pr_list.return_value = [
                    {"number": 1, "title": "PR 1"},
                ]

                cmd.github_client = mock.Mock()
                cmd.quota_manager = mock.Mock()
                cmd.quota_manager.check_sufficient.return_value = (False, 0)
                cmd.config = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.logger = mock.Mock()

                result = cmd._fetch_repository(
                    "owner",
                    "repo",
                    datetime(2024, 1, 1, tzinfo=timezone.utc),
                    datetime(2024, 2, 1, tzinfo=timezone.utc),
                    2,
                )

                assert result == 1
                cmd.logger.error.assert_called()

    def test_fetch_regular_invalid_date(self):
        """Test regular fetch with invalid date."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            start="invalid-date",
            end=None,
            update=False,
            all=False,
            pr=None,
            wait=False,
            workers=4,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = FetchCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.logger = mock.Mock()

            result = cmd.run(args)

            assert result == 1
            cmd.logger.error.assert_called()


class TestCsvCommand:
    """Unit tests for CsvCommand."""

    def test_csv_basic_success(self, tmp_path):
        """Test basic CSV generation."""
        from datetime import datetime, timezone

        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            output=str(tmp_path / "test.csv"),
            all=False,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_generate_csv_for_repo", return_value=0) as mock_gen:
                # Mock dependencies
                cmd.config = mock.Mock()
                cmd.logger = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_repo_state.return_value = {
                    "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                    "csv_file": str(tmp_path / "test.csv"),
                }

                # Run command
                result = cmd.run(args)

                # Verify success
                assert result == 0
                mock_gen.assert_called_once()

    def test_csv_all_repos(self):
        """Test CSV generation for all tracked repos."""
        args = argparse.Namespace(
            owner=None,
            repo=None,
            output=None,
            all=True,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_generate_csv_for_repo", return_value=0):
                # Mock dependencies
                cmd.config = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_all_tracked_repos.return_value = [
                    {"owner": "owner1", "repo": "repo1", "csv_file": "test1.csv"},
                    {"owner": "owner2", "repo": "repo2", "csv_file": "test2.csv"},
                ]
                cmd.logger = mock.Mock()

                # Run command
                result = cmd.run(args)

                # Verify success
                assert result == 0

    def test_csv_missing_required_args(self):
        """Test CSV generation without required args."""
        args = argparse.Namespace(
            owner=None,
            repo="testrepo",
            output=None,
            all=False,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.logger = mock.Mock()

            # Run command
            result = cmd.run(args)

            # Verify failure
            assert result == 1
            cmd.logger.error.assert_called()

    def test_csv_all_repos_no_tracked_repos(self):
        """Test CSV generation with no tracked repos."""
        args = argparse.Namespace(
            owner=None,
            repo=None,
            output=None,
            all=True,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.config = mock.Mock()
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_all_tracked_repos.return_value = []
            cmd.logger = mock.Mock()

            result = cmd.run(args)

            assert result == 0  # Not an error, just nothing to do

    def test_csv_all_repos_skip_missing_csv_file(self):
        """Test CSV generation skips repos without csv_file."""
        args = argparse.Namespace(
            owner=None,
            repo=None,
            output=None,
            all=True,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_generate_csv_for_repo", return_value=0) as mock_gen:
                cmd.config = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_all_tracked_repos.return_value = [
                    {"owner": "owner1", "repo": "repo1"},  # No csv_file
                    {"owner": "owner2", "repo": "repo2", "csv_file": "test2.csv"},
                ]
                cmd.logger = mock.Mock()

                result = cmd.run(args)

                assert result == 0
                # Should only process second repo
                assert mock_gen.call_count == 1

    def test_csv_all_repos_with_failures(self):
        """Test CSV generation handles failures."""
        args = argparse.Namespace(
            owner=None,
            repo=None,
            output=None,
            all=True,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_generate_csv_for_repo", side_effect=[1, 0]):
                cmd.config = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_all_tracked_repos.return_value = [
                    {"owner": "owner1", "repo": "repo1", "csv_file": "test1.csv"},
                    {"owner": "owner2", "repo": "repo2", "csv_file": "test2.csv"},
                ]
                cmd.logger = mock.Mock()

                result = cmd.run(args)

                assert result == 1  # Should fail
                cmd.logger.error.assert_called()

    def test_csv_resolve_output_path_cli_arg(self):
        """Test output path resolution prioritizes CLI argument."""
        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.state_manager = mock.Mock()
            cmd.config = mock.Mock()

            output = cmd._resolve_output_path("owner", "repo", "cli-output.csv")

            assert output == "cli-output.csv"

    def test_csv_resolve_output_path_state_file(self):
        """Test output path resolution uses state file."""
        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_repo_state.return_value = {"csv_file": "state-output.csv"}
            cmd.config = mock.Mock()

            output = cmd._resolve_output_path("owner", "repo", None)

            assert output == "state-output.csv"

    def test_csv_resolve_output_path_config_pattern(self):
        """Test output path resolution uses config pattern."""
        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch("gh_pr_metrics.expand_output_pattern", return_value="owner-repo.csv"):
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_repo_state.return_value = None
                cmd.config = mock.Mock()
                cmd.config.output_pattern = "output-{repo}.csv"

                output = cmd._resolve_output_path("owner", "repo", None)

                assert output == "owner-repo.csv"

    def test_csv_resolve_output_path_none(self):
        """Test output path resolution returns None when no source."""
        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.state_manager = mock.Mock()
            cmd.state_manager.get_repo_state.return_value = None
            cmd.config = mock.Mock()
            cmd.config.output_pattern = None

            output = cmd._resolve_output_path("owner", "repo", None)

            assert output is None

    def test_csv_single_no_output_path(self):
        """Test CSV generation fails when no output path can be determined."""
        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            output=None,
            all=False,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_resolve_output_path", return_value=None):
                cmd.logger = mock.Mock()

                result = cmd.run(args)

                assert result == 1
                cmd.logger.error.assert_called()

    def test_csv_single_updates_state_when_output_provided(self):
        """Test CSV generation updates state when --output is provided."""
        from datetime import datetime, timezone

        args = argparse.Namespace(
            owner="testowner",
            repo="testrepo",
            output="new-output.csv",
            all=False,
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            with mock.patch.object(cmd, "_generate_csv_for_repo", return_value=0):
                cmd.config = mock.Mock()
                cmd.logger = mock.Mock()
                cmd.state_manager = mock.Mock()
                cmd.state_manager.get_repo_state.return_value = {
                    "timestamp": datetime(2024, 1, 1, tzinfo=timezone.utc),
                }

                result = cmd.run(args)

                assert result == 0
                # Should update state with new csv_file
                cmd.state_manager.update_repo.assert_called_once()

    def test_csv_generate_no_json_dir(self, tmp_path):
        """Test CSV generation when no JSON directory exists."""
        cmd = CsvCommand()

        with mock.patch.object(cmd, "setup"):
            cmd.config = mock.Mock()
            cmd.config.raw_data_dir = str(tmp_path / "raw")
            cmd.logger = mock.Mock()

            result = cmd._generate_csv_for_repo("owner", "repo", "output.csv")

            assert result == 0  # Not an error
            cmd.logger.warning.assert_called()

    def test_csv_generate_no_json_files(self, tmp_path):
        """Test CSV generation when JSON directory is empty."""
        cmd = CsvCommand()

        # Create empty directory
        json_dir = tmp_path / "raw" / "github.com" / "owner" / "repo"
        json_dir.mkdir(parents=True)

        with mock.patch.object(cmd, "setup"):
            cmd.config = mock.Mock()
            cmd.config.raw_data_dir = str(tmp_path / "raw")
            cmd.logger = mock.Mock()

            result = cmd._generate_csv_for_repo("owner", "repo", "output.csv")

            assert result == 0
            cmd.logger.warning.assert_called()

    def test_csv_generate_success(self, tmp_path):
        """Test successful CSV generation from JSON files."""
        import json

        cmd = CsvCommand()

        # Create JSON files
        json_dir = tmp_path / "raw" / "github.com" / "owner" / "repo"
        json_dir.mkdir(parents=True)

        pr_data = {
            "title": "Test PR",
            "author": "testuser",
            "created_at": "2024-01-01T00:00:00Z",
            "url": "https://github.com/owner/repo/pull/1",
            "state": "open",
            "draft": False,
            "additions": 10,
            "deletions": 5,
            "changed_files": 2,
        }
        (json_dir / "1.json").write_text(json.dumps(pr_data))

        output_file = tmp_path / "output.csv"

        with mock.patch.object(cmd, "setup"):
            with mock.patch("commands.csv_command.MetricsGenerator") as mock_gen_class:
                mock_gen = mock.Mock()
                mock_gen_class.return_value = mock_gen
                mock_gen.read_pr_json.return_value = pr_data
                mock_gen.calculate_metrics.return_value = {"pr_number": 1, "title": "Test PR"}

                cmd.config = mock.Mock()
                cmd.config.raw_data_dir = str(tmp_path / "raw")
                cmd.csv_manager = mock.Mock()
                cmd.logger = mock.Mock()

                result = cmd._generate_csv_for_repo("owner", "repo", str(output_file))

                assert result == 0
                cmd.csv_manager.write_csv.assert_called_once()

    def test_csv_generate_handles_processing_errors(self, tmp_path):
        """Test CSV generation handles errors processing individual PRs."""
        cmd = CsvCommand()

        # Create JSON files
        json_dir = tmp_path / "raw" / "github.com" / "owner" / "repo"
        json_dir.mkdir(parents=True)
        (json_dir / "invalid.json").write_text("not a number")

        output_file = tmp_path / "output.csv"

        with mock.patch.object(cmd, "setup"):
            cmd.config = mock.Mock()
            cmd.config.raw_data_dir = str(tmp_path / "raw")
            cmd.csv_manager = mock.Mock()
            cmd.logger = mock.Mock()

            result = cmd._generate_csv_for_repo("owner", "repo", str(output_file))

            # Should log warning but continue
            assert result == 0
            cmd.logger.warning.assert_called()

    def test_csv_generate_write_failure(self, tmp_path):
        """Test CSV generation handles write failures."""
        import json

        cmd = CsvCommand()

        # Create JSON files
        json_dir = tmp_path / "raw" / "github.com" / "owner" / "repo"
        json_dir.mkdir(parents=True)

        pr_data = {"title": "Test PR", "author": "testuser", "created_at": "2024-01-01T00:00:00Z"}
        (json_dir / "1.json").write_text(json.dumps(pr_data))

        with mock.patch.object(cmd, "setup"):
            with mock.patch("commands.csv_command.MetricsGenerator") as mock_gen_class:
                mock_gen = mock.Mock()
                mock_gen_class.return_value = mock_gen
                mock_gen.read_pr_json.return_value = pr_data
                mock_gen.calculate_metrics.return_value = {"pr_number": 1}

                cmd.config = mock.Mock()
                cmd.config.raw_data_dir = str(tmp_path / "raw")
                cmd.csv_manager = mock.Mock()
                cmd.csv_manager.write_csv.side_effect = Exception("Write error")
                cmd.logger = mock.Mock()

                result = cmd._generate_csv_for_repo("owner", "repo", "output.csv")

                assert result == 1
                cmd.logger.error.assert_called()


class TestBaseCommand:
    """Unit tests for BaseCommand common functionality."""

    def test_setup_initializes_managers(self):
        """Test that setup properly initializes all managers."""
        args = argparse.Namespace(
            config=".gh-pr-metrics.yaml",
            debug=False,
        )

        cmd = InitCommand()

        # Mock config loading and dependencies
        with mock.patch("managers.load_config") as mock_load:
            mock_config = mock.Mock()
            mock_config.log_file = None
            mock_config.raw_data_dir = "raw_data"
            mock_load.return_value = mock_config

            with mock.patch("github_api.GitHubClient"):
                with mock.patch.object(cmd, "_get_github_token", return_value="fake-token"):
                    # Run setup
                    cmd.setup(args)

                    # Verify managers are initialized
                    assert cmd.config is not None
                    assert cmd.state_manager is not None
                    assert cmd.quota_manager is not None
                    assert cmd.csv_manager is not None
                    assert cmd.logger is not None
                    assert cmd.github_client is not None

    def test_setup_respects_debug_flag(self):
        """Test that setup respects debug flag for logging."""
        args = argparse.Namespace(
            config=".gh-pr-metrics.yaml",
            debug=True,
        )

        cmd = FetchCommand()

        with mock.patch("managers.load_config") as mock_load:
            mock_config = mock.Mock()
            mock_config.log_file = None
            mock_config.raw_data_dir = "raw_data"
            mock_load.return_value = mock_config

            with mock.patch("github_api.GitHubClient"):
                with mock.patch.object(cmd, "_get_github_token", return_value="fake-token"):
                    # Run setup
                    cmd.setup(args)

                    # Verify managers initialized (debug flag handled by basicConfig)
                    assert cmd.config is not None
