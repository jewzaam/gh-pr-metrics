# GitHub PR Metrics - Logic Flow

Generated By: Cursor (Claude Sonnet 4.5)

## Super High-Level: Core Blocks & Flow

```mermaid
flowchart TD
    Start([Start/Resume]) --> InitQuota[Init Quota Block:<br/>Get token<br/>Call /rate_limit API<br/>Set globals: remaining, limit, reset]
    
    InitQuota --> PickWork{Select Work}
    
    PickWork -->|--init| InitRepos[Init Repos Block:<br/>List repos<br/>Create state entries<br/>Exit]
    PickWork -->|--update-all| PickRepo[Pick Next Repo:<br/>From state file<br/>Sorted oldest first]
    PickWork -->|--update or regular| ProcessSingle[Process Single Repo]
    
    PickRepo --> CheckQuota{Quota<br/>Available?}
    CheckQuota -->|No + --wait| WaitBlock[Wait Block:<br/>Log wait time<br/>Sleep until reset<br/>Loop back to Start]
    CheckQuota -->|No| PrintSummary[Print Summary Block:<br/>Completed count<br/>Partial repo info<br/>Unprocessed count]
    WaitBlock --> Start
    
    CheckQuota -->|Yes| ProcessSingle
    ProcessSingle --> ProcessResult{Result?}
    
    ProcessResult -->|Error + --wait| WaitBlock
    ProcessResult -->|Error| PrintSummary
    ProcessResult -->|Success| MoreWork{More<br/>Work?}
    
    MoreWork -->|Yes| PickRepo
    MoreWork -->|No| PrintSummary
    
    InitRepos --> End([End])
    PrintSummary --> End
    
    style InitQuota fill:#e1f5ff
    style WaitBlock fill:#fff4e1
    style ProcessSingle fill:#e8f5e9
    style PrintSummary fill:#f3e5f5
    style Start fill:#ffebee
```

### Block Commonalities

**Init Quota Block** (Used by):
- Startup (always)
- Post-wait resume (loops back)
- **Key**: Single source of truth for quota initialization

**Wait Block** (Triggered by):
- Quota exhausted at update-all start
- Quota exhausted between repos  
- **Key**: Same logic, always loops back to Init Quota

**Print Summary Block** (Used by):
- Normal completion
- Error/exhaustion without --wait
- **Key**: Terminal state, shows progress made

**Process Single Repo** (Used by):
- Update-all loop (per repo)
- Update mode (one repo)
- Regular mode (one repo)
- **Key**: Shared processing logic for all modes

### Resume After Wait

```
Wait Block → Start → Init Quota Block
              ↓
         Reinitialize globals (remaining, limit, reset)
              ↓
         Return to original work (update-all loop continues)
```

**No special refresh code** - just restart initialization and continue.

## High-Level Flow

```mermaid
flowchart TD
    Start([Start]) --> ParseArgs[Parse Arguments]
    ParseArgs --> ValidateArgs{Validate<br/>Arguments}
    ValidateArgs -->|Invalid| ErrorExit[Exit with Error]
    ValidateArgs -->|Valid| GetToken[Get GitHub Token]
    
    GetToken --> CheckRateLimit[Check Rate Limit<br/>Initialize Global Quota<br/>remaining, limit, reset]
    CheckRateLimit --> ModeSwitch{Mode?}
    
    ModeSwitch -->|--init| InitMode[Init Mode:<br/>List repos, validate access,<br/>create state entries]
    ModeSwitch -->|--update-all| UpdateAllMode[Update-All Mode]
    ModeSwitch -->|--update| UpdateMode[Update Mode]
    ModeSwitch -->|Regular| RegularMode[Regular Mode]
    
    InitMode --> End([End])
    
    %% Update-All Mode
    UpdateAllMode --> LoadTrackedRepos[Load Tracked Repos<br/>from State File]
    LoadTrackedRepos --> SortRepos[Sort by Timestamp<br/>Oldest First]
    SortRepos --> PickNextRepo[Pick Next Repo]
    
    PickNextRepo --> CheckQuota{Quota > 0?}
    CheckQuota -->|No + --wait| WaitForReset[Wait for Reset<br/>Sleep until reset timestamp]
    CheckQuota -->|No| ErrorExit
    WaitForReset --> CheckRateLimit
    CheckQuota -->|Yes| ProcessRepo[Process Repository]
    
    ProcessRepo --> RepoResult{Success?}
    RepoResult -->|Error + --wait| WaitForReset
    RepoResult -->|Error| ErrorExit
    RepoResult -->|Yes| MoreRepos{More<br/>Repos?}
    MoreRepos -->|Yes| PickNextRepo
    MoreRepos -->|No| Summary[Print Summary:<br/>completed, partial, unprocessed]
    Summary --> End
    
    %% Update Mode
    UpdateMode --> LoadState[Load Repo State<br/>timestamp + csv_file]
    LoadState --> ProcessRepo
    
    %% Regular Mode
    RegularMode --> DetermineRepo[Determine Owner/Repo<br/>from args or git]
    DetermineRepo --> SetDateRange[Set Date Range<br/>from args or defaults]
    SetDateRange --> OutputCheck{Has<br/>--output?}
    OutputCheck -->|Yes| ProcessRepo
    OutputCheck -->|No| StdoutMode[Fetch All PRs<br/>Process All<br/>Write to Stdout<br/>No State Tracking]
    StdoutMode --> End
    
    ErrorExit --> End
```

## Repository Processing Flow

```mermaid
flowchart TD
    Start([Process Repository]) --> CheckQuotaStart{Quota<br/>Sufficient?}
    CheckQuotaStart -->|No| ErrorExit[Return: Error]
    CheckQuotaStart -->|Yes| InitVars[Initialize:<br/>page=1, last_timestamp=start_date]
    
    InitVars --> FetchPage[Fetch Page of PRs<br/>sort=updated, direction=asc<br/>100 per page]
    
    FetchPage --> HasPRs{Found<br/>PRs?}
    HasPRs -->|No| UpdateStateNoData[Update State:<br/>timestamp=end_date<br/>Marks range as scanned]
    UpdateStateNoData --> ReturnSuccess[Return: Success]
    
    HasPRs -->|Yes| CheckPageQuota{Quota for<br/>Full Page?}
    CheckPageQuota -->|Yes| UseFullPage[Use All PRs]
    CheckPageQuota -->|No, but > 0| TruncatePage[Truncate to max_prs<br/>Force has_more=false]
    CheckPageQuota -->|No, = 0| ReturnPartial[Return: Partial Success]
    
    TruncatePage --> ProcessPRs[Process PRs in Parallel<br/>ThreadPoolExecutor<br/>workers threads]
    UseFullPage --> ProcessPRs
    
    ProcessPRs --> WriteMerge[Write CSV:<br/>Read existing by PR#<br/>Update dict<br/>Write all<br/>Atomic rename]
    WriteMerge --> UpdateState[Update State:<br/>timestamp=last PR updated_at]
    UpdateState --> MorePages{has_more<br/>pages?}
    
    MorePages -->|Yes| NextPage[page++]
    MorePages -->|No| ReturnSuccess
    NextPage --> FetchPage
    
    ErrorExit --> End([End])
    ReturnSuccess --> End
    ReturnPartial --> End
```

## PR Processing Flow

```mermaid
flowchart TD
    Start([Process PR]) --> ExtractBasic[Extract Basic Info<br/>number, title, author, url]
    
    ExtractBasic --> GetReady[Get Ready for Review Time<br/>Check timeline events]
    GetReady --> CountComments[Count Comments<br/>Separate AI bots]
    CountComments --> GetReviews[Get Review Metrics<br/>changes requested, approvals]
    GetReviews --> DetermineStatus[Determine Status<br/>draft, open, closed, merged]
    
    DetermineStatus --> BuildMetrics[Build Metrics Dict]
    BuildMetrics --> End([Return Metrics])
```

## Quota Management Flow

```mermaid
flowchart TD
    Start([API Request]) --> MakeRequest[Make GitHub API Request]
    MakeRequest --> UpdateFromHeaders[Update Quota from<br/>Response Headers]
    
    UpdateFromHeaders --> UpdateGlobal[Update Global Variables<br/>remaining, limit, reset<br/>Thread-safe with Lock]
    
    UpdateGlobal --> FormatQuota[Format Quota String<br/>'API XXXX/YYYY']
    FormatQuota --> PrefixLogs[Prefix All Log Lines]
    
    CheckBefore([Before Processing]) --> CalcMax[Calculate max_prs<br/>remaining - 5% reserve]
    CalcMax --> Sufficient{Sufficient?}
    
    Sufficient -->|No + --wait| Wait[Wait for Reset<br/>Sleep until timestamp]
    Sufficient -->|No| Fail[Fail Fast]
    Sufficient -->|Yes| Continue[Continue Processing]
    
    Wait --> RefreshQuota[Refresh Quota<br/>Like Startup]
    RefreshQuota --> CalcMax
```

## State File Management Flow

```mermaid
flowchart TD
    Start([State Operations]) --> Operation{Operation?}
    
    Operation -->|Load| LoadYAML[Load ~/.gh-pr-metrics-state.yaml]
    LoadYAML --> ParseState[Parse YAML<br/>repo_url -> {timestamp, csv_file}]
    
    Operation -->|Save| BuildState[Build State Dict<br/>https://github.com/owner/repo]
    BuildState --> WriteYAML[Write YAML<br/>Sorted by Keys]
    
    Operation -->|Update| GetRepoState[Get Repo State Entry]
    GetRepoState --> ValidateEntry{Valid?}
    ValidateEntry -->|No| ErrorState[Error: Invalid State]
    ValidateEntry -->|Yes| ExtractData[Extract timestamp + csv_file]
    ExtractData --> ReturnData[Return Data]
    
    Operation -->|Get All| LoadAll[Load All Repos]
    LoadAll --> SortByTime[Sort by Timestamp<br/>Oldest First]
    SortByTime --> ReturnList[Return List]
    
    ParseState --> End([End])
    WriteYAML --> End
    ErrorState --> End
    ReturnData --> End
    ReturnList --> End
```

## CSV Merge Flow

```mermaid
flowchart TD
    Start([Write CSV]) --> MergeMode{Merge Mode?}
    
    MergeMode -->|No| WriteNew[Write New CSV<br/>Headers + Rows]
    
    MergeMode -->|Yes| LoadExisting[Load Existing CSV<br/>Into Dict by PR#]
    LoadExisting --> MergeNew[Update Dict with<br/>New PR Metrics]
    MergeNew --> ConvertList[Convert to List<br/>Order doesn't matter]
    ConvertList --> WriteTemp[Write to Temp File]
    
    WriteTemp --> AtomicRename[Atomic Rename<br/>temp -> target]
    AtomicRename --> End([End])
    WriteNew --> End
```

## Key Design Decisions

### Unified Initialization
- **Single entry point**: All flows (startup, post-wait) go through "Check Rate Limit"
- **No special refresh**: Waiting just restarts from the top
- **Simplifies logic**: One place to initialize quota tracking

### Quota-Driven Iteration
- **Check before each repo**: Not just at start of update-all
- **Global quota check in loop**: `Pick Next Repo → Quota > 0? → Process`
- **Efficiency**: Skip iteration overhead when quota exhausted
- **Optimization opportunity**: Could check quota once per repo instead of per-page

### Page-Based Processing
- Fetch 100 PRs per page (sorted by `updated` ASC - oldest first)
- Process immediately, don't load all into memory
- Truncate page if quota insufficient (process what we can)
- Save state after each page (resume point = last PR timestamp)

### Quota Tracking
- Global variables: `_api_quota_remaining`, `_api_quota_limit`, `_api_quota_reset`
- Updated from every API response header (no extra `/rate_limit` calls)
- Thread-safe with mutex lock
- Visible in all logs: `[API 4693/5000]`

### State Management
- YAML file: `~/.gh-pr-metrics-state.yaml`
- Format: `https://github.com/owner/repo: {timestamp, csv_file}`
- Timestamp = last processed PR's `updated_at` (or `end_date` if none found)
- Enables precise resume and `--update-all` workflow

### Wait Strategy
- Single "Wait for Reset" block used by all flows
- Sleeps until global `_api_quota_reset` timestamp + 15sec buffer
- Loops back to initialization (clean restart)
- No special "refresh" - just reinitialize like startup

