# Generated By: Cursor (Claude Sonnet 4.5)
"""Tests for main application flow."""

import sys
import tempfile
from pathlib import Path
from unittest import mock

import gh_pr_metrics


class TestMain:
    """Test main application entry point."""

    def test_main_returns_error_without_repo(self, default_config):
        """Test that main() returns error when repo cannot be determined."""
        with mock.patch.object(sys, "argv", ["gh-pr-metrics"]):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch("gh_pr_metrics.get_repo_from_git", return_value=(None, None)):
                    result = gh_pr_metrics.main()
                    assert result == 1

    def test_main_with_explicit_repo(self, requests_mock, default_config):
        """Test main with explicitly specified repo."""
        # Mock the GitHub API to return empty PRs list
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls",
            json=[],
        )

        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo"],
        ):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                result = gh_pr_metrics.main()
                assert result == 0

    def test_main_update_mode_requires_output(self, default_config):
        """Test that update mode requires --output flag."""
        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo", "--update"],
        ):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch(
                    "gh_pr_metrics.get_repo_from_git", return_value=("testowner", "testrepo")
                ):
                    result = gh_pr_metrics.main()
                    assert result == 1

    def test_main_update_mode_with_existing_state(self, requests_mock, tmp_path, default_config):
        """Test update mode uses last update date from state file."""
        state_file = tmp_path / "state.yaml"
        output_file = tmp_path / "test.csv"

        # Create initial CSV
        output_file.write_text("pr_number,title\n")

        # Create state with stored CSV path
        state_file.write_text(
            f"https://github.com/testowner/testrepo:\n"
            f"  csv_file: {output_file}\n"
            f"  timestamp: '2024-01-01T00:00:00'\n"
        )

        # Mock the GitHub API to return empty PRs list
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls",
            json=[],
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo", "--update"],
        ):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    result = gh_pr_metrics.main()
                    assert result == 0

    def test_main_update_mode_without_existing_state(self, tmp_path, default_config):
        """Test update mode fails when no state exists."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo", "--update"],
        ):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    result = gh_pr_metrics.main()
                    assert result == 1  # Should fail - no state

    def test_main_update_all_no_tracked_repos(self, tmp_path, default_config):
        """Test --update-all fails when no repos are tracked."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    result = gh_pr_metrics.main()
                    assert result == 1

    def test_main_update_all_with_tracked_repos(self, requests_mock, tmp_path, default_config):
        """Test --update-all processes all tracked repositories."""
        state_file = tmp_path / "state.yaml"
        csv_file1 = tmp_path / "repo1.csv"
        csv_file2 = tmp_path / "repo2.csv"

        # Create initial CSV files
        csv_file1.write_text("pr_number,title\n")
        csv_file2.write_text("pr_number,title\n")

        # Create state with two repos
        state_file.write_text(
            f"https://github.com/owner1/repo1:\n"
            f"  csv_file: {csv_file1}\n"
            f"  timestamp: '2024-01-01T00:00:00Z'\n"
            f"https://github.com/owner2/repo2:\n"
            f"  csv_file: {csv_file2}\n"
            f"  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        # Mock GitHub API for both repos
        requests_mock.get(
            "https://api.github.com/repos/owner1/repo1/pulls",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/owner2/repo2/pulls",
            json=[],
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    result = gh_pr_metrics.main()
                    assert result == 0

    def test_main_update_all_with_partial_failure(self, requests_mock, tmp_path, default_config):
        """Test --update-all continues after individual repo failure."""
        state_file = tmp_path / "state.yaml"
        csv_file1 = tmp_path / "repo1.csv"
        csv_file2 = tmp_path / "repo2.csv"

        # Create initial CSV files
        csv_file1.write_text("pr_number,title\n")
        csv_file2.write_text("pr_number,title\n")

        # Create state with two repos
        state_file.write_text(
            f"https://github.com/owner1/repo1:\n"
            f"  csv_file: {csv_file1}\n"
            f"  timestamp: '2024-01-01T00:00:00Z'\n"
            f"https://github.com/owner2/repo2:\n"
            f"  csv_file: {csv_file2}\n"
            f"  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        # Mock GitHub API - first fails, second succeeds
        requests_mock.get(
            "https://api.github.com/repos/owner1/repo1/pulls",
            status_code=404,
        )
        requests_mock.get(
            "https://api.github.com/repos/owner2/repo2/pulls",
            json=[],
        )

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    result = gh_pr_metrics.main()
                    assert result == 1  # Returns failure due to partial failure

    def test_main_update_all_skips_repo_without_csv(self, tmp_path, requests_mock, default_config):
        """Test --update-all skips repos without CSV file in state."""
        state_file = tmp_path / "state.yaml"
        csv_file = tmp_path / "repo.csv"

        # Create initial CSV file for one repo
        csv_file.write_text("pr_number,title\n")

        # Create state with one repo missing csv_file
        state_file.write_text(
            "https://github.com/owner1/repo1:\n"
            "  timestamp: '2024-01-01T00:00:00Z'\n"
            f"https://github.com/owner2/repo2:\n"
            f"  csv_file: {csv_file}\n"
            f"  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    with mock.patch(
                        "gh_pr_metrics.process_repository", return_value=(0, 1, 1)
                    ) as mock_process:
                        result = gh_pr_metrics.main()
                        # Should only process one repo
                        assert mock_process.call_count == 1
                        assert result == 0

    def test_main_update_all_restarts_from_beginning_with_wait(self, requests_mock, default_config):
        """Test that update-all with --wait restarts from beginning when repo fails."""
        state_file = Path(tempfile.mkdtemp()) / "state.yaml"

        # State with one repo
        state_file.write_text(
            "https://github.com/testowner/repo1:\n"
            "  timestamp: '2024-01-01T00:00:00'\n"
            "  csv_file: test.csv\n"
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        call_count = 0

        def process_side_effect(*args, **kwargs):
            nonlocal call_count
            call_count += 1
            return (0, 1, 1) if call_count == 2 else (1, 0, 0)  # Fail first, succeed second

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all", "--wait"]):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    with mock.patch("gh_pr_metrics.process_repository") as mock_process:
                        with mock.patch.object(
                            gh_pr_metrics.quota_manager, "wait_for_reset", return_value=True
                        ):
                            mock_process.side_effect = process_side_effect
                            result = gh_pr_metrics.main()

                # Should call process_repository twice (fail, wait, retry same repo)
                assert mock_process.call_count == 2
                # Both calls for same repo (restart from beginning)
                assert mock_process.call_args_list[0][0][0] == "testowner"
                assert mock_process.call_args_list[0][0][1] == "repo1"
                assert mock_process.call_args_list[1][0][0] == "testowner"
                assert mock_process.call_args_list[1][0][1] == "repo1"
                assert result == 0  # Success on retry

    def test_update_all_reloads_state_on_restart(self, tmp_path, requests_mock, default_config):
        """
        Test that update-all reloads state file on restart after quota reset.

        Critical bug: Previously loaded state once and reused stale timestamps,
        causing repos with updated timestamps to be re-processed unnecessarily.

        Scenario:
        - repo1 (old timestamp) processes successfully, updates to new timestamp
        - repo2 (newer timestamp) fails partway, triggers restart
        - On restart: Should pick repo2 (still older than repo1's NEW timestamp)
        - Bug would pick repo1 again (using stale OLD timestamp from initial load)
        """
        state_file = tmp_path / "state.yaml"
        csv1 = tmp_path / "repo1.csv"
        csv2 = tmp_path / "repo2.csv"

        # Initial state: repo1 is older
        from datetime import datetime, timezone, timedelta

        now = datetime.now(timezone.utc)
        repo1_old = (now - timedelta(hours=24)).replace(tzinfo=None)
        repo2_initial = (now - timedelta(hours=12)).replace(tzinfo=None)

        state_file.write_text(
            f"https://github.com/testowner/repo1:\n"
            f"  csv_file: {csv1}\n"
            f"  timestamp: '{repo1_old.isoformat()}'\n"
            f"https://github.com/testowner/repo2:\n"
            f"  csv_file: {csv2}\n"
            f"  timestamp: '{repo2_initial.isoformat()}'\n"
        )

        # Create CSV files
        csv1.write_text("pr_number,title\n")
        csv2.write_text("pr_number,title\n")

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        # Track processing order
        call_count = 0

        def mock_process_repository(owner, repo, *args, **kwargs):
            nonlocal call_count
            call_count += 1

            # First: repo1 (oldest initially) - update to very new timestamp
            if call_count == 1:
                assert owner == "testowner" and repo == "repo1"
                # Update state file: repo1 now has newest timestamp (1 hour ago)
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    repo1_new = (now - timedelta(hours=1)).replace(tzinfo=None)
                    gh_pr_metrics.state_manager.update_repo(owner, repo, repo1_new, str(csv1))
                return 0, 1, 1

            # Second: repo2 (now oldest after repo1 update) - fail to trigger restart
            elif call_count == 2:
                assert owner == "testowner" and repo == "repo2"
                return 1, 0, 0  # Fail

            # Third (after restart): Should be repo2 again (still oldest)
            # If bug exists, would incorrectly be repo1 (using stale timestamp)
            elif call_count == 3:
                # CRITICAL ASSERTION: State was reloaded, repo2 is still oldest
                assert (
                    owner == "testowner" and repo == "repo2"
                ), "Bug: Picked wrong repo on restart (state not reloaded)"
                return 0, 1, 1

            # Fourth: repo1 (now newest, processed last)
            elif call_count == 4:
                assert owner == "testowner" and repo == "repo1"
                return 0, 1, 1

            return 0, 1, 1

        with mock.patch("gh_pr_metrics.process_repository", side_effect=mock_process_repository):
            with mock.patch("gh_pr_metrics.load_config", return_value=default_config):
                with mock.patch.object(
                    gh_pr_metrics.quota_manager, "wait_for_reset", return_value=True
                ):
                    with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                        with mock.patch.object(
                            sys,
                            "argv",
                            ["gh-pr-metrics", "--update-all", "--wait"],
                        ):
                            result = gh_pr_metrics.main()

        # Should process: repo1, repo2, [restart], repo2, repo1
        assert call_count == 4
        assert result == 0


class TestProcessRepository:
    """Test process_repository function behavior."""

    def test_returns_error_when_quota_exhausted_mid_processing(
        self, tmp_path, requests_mock, default_config
    ):
        """Test that process_repository returns error code when quota exhausted."""
        state_file = tmp_path / "state.yaml"
        output_file = tmp_path / "output.csv"

        from datetime import datetime, timezone

        start_date = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2024, 1, 31, 0, 0, 0, tzinfo=timezone.utc)

        # Initialize github_client
        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        # Mock fetch_all_prs to return many PRs
        with mock.patch.object(
            gh_pr_metrics.github_client,
            "fetch_all_prs",
            return_value=[
                {
                    "number": i,
                    "title": f"PR {i}",
                    "updated_at": "2024-01-15T00:00:00Z",
                    "created_at": "2024-01-01T00:00:00Z",
                    "state": "open",
                    "user": {"login": "test"},
                    "html_url": f"https://github.com/test/test/pull/{i}",
                    "draft": False,
                    "comments_url": f"https://api.github.com/repos/test/test/issues/{i}/comments",
                    "review_comments_url": (
                        f"https://api.github.com/repos/test/test/pulls/{i}/comments"
                    ),
                }
                for i in range(200)  # 200 PRs = 2 chunks
            ],
        ):
            # Mock quota check to fail on second chunk
            call_count = 0

            def mock_check_sufficient(
                estimated_calls, repo_ctx, chunk_info="", token_getter=None, logger=None
            ):
                nonlocal call_count
                call_count += 1
                if call_count == 1:
                    return True, 50  # First chunk: sufficient
                else:
                    return False, 0  # Second chunk: exhausted

            with mock.patch.object(
                gh_pr_metrics.quota_manager, "check_sufficient", side_effect=mock_check_sufficient
            ):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    # Mock process_pr to succeed quickly
                    with mock.patch(
                        "gh_pr_metrics.process_pr", return_value={"pr_number": 1, "title": "test"}
                    ):
                        exit_code, chunks_completed, total_chunks = (
                            gh_pr_metrics.process_repository(
                                owner="test",
                                repo="test",
                                output_file=str(output_file),
                                start_date=start_date,
                                end_date=end_date,
                                token="fake",
                                workers=1,
                                config=default_config,
                                merge_mode=False,
                            )
                        )

        # Should return error code when stopping due to quota
        assert exit_code == 1
        assert chunks_completed == 1  # Only completed first chunk
        assert total_chunks == 2  # Expected 2 chunks total

    def test_no_csv_created_when_no_prs(self, tmp_path, requests_mock, default_config):
        """Test that process_repository does not create CSV when no PRs found."""
        state_file = tmp_path / "state.yaml"
        output_file = tmp_path / "output.csv"

        from datetime import datetime, timezone

        start_date = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2024, 1, 31, 0, 0, 0, tzinfo=timezone.utc)

        # Mock empty PR list
        requests_mock.get("https://api.github.com/repos/test/test/pulls", json=[])

        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            exit_code, chunks_completed, total_chunks = gh_pr_metrics.process_repository(
                owner="test",
                repo="test",
                output_file=str(output_file),
                start_date=start_date,
                end_date=end_date,
                token="fake",
                workers=1,
                config=default_config,
                merge_mode=False,
            )

            # Should succeed with no PRs
            assert exit_code == 0
            # CSV should NOT be created
            assert not output_file.exists()
            # State should be updated (check inside mock context)
            state = gh_pr_metrics.state_manager.load()
            assert "https://github.com/test/test" in state


class TestUpdateSinglePR:
    """Test update_single_pr function behavior."""

    def test_update_single_pr_updates_existing_pr(self, requests_mock, tmp_path, default_config):
        """Test that update_single_pr updates an existing PR in CSV."""
        output_file = tmp_path / "output.csv"

        # Create existing CSV with some data
        output_file.write_text(
            "pr_number,title,author,created_at,ready_for_review_at,merged_at,closed_at,"
            "days_open,days_in_review,total_comment_count,non_ai_bot_comment_count,"
            "ai_bot_comment_count,non_ai_bot_login_names,ai_bot_login_names,"
            "changes_requested_count,unique_change_requesters,approval_count,status,url,errors\n"
            "123,Old Title,oldauthor,2024-01-01T00:00:00Z,2024-01-01T00:00:00Z,,,"
            "5.0,5.0,2,2,0,user1,,0,0,0,open,https://github.com/test/test/pull/123,\n"
            "456,Another PR,author2,2024-01-02T00:00:00Z,2024-01-02T00:00:00Z,,,"
            "3.0,3.0,1,1,0,user2,,0,0,0,open,https://github.com/test/test/pull/456,\n"
        )

        # Mock PR fetch
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls/123",
            json={
                "number": 123,
                "title": "Updated Title",
                "user": {"login": "newauthor"},
                "created_at": "2024-01-01T00:00:00Z",
                "updated_at": "2024-01-05T00:00:00Z",
                "draft": False,
                "state": "open",
                "merged_at": None,
                "closed_at": None,
                "html_url": "https://github.com/test/test/pull/123",
                "comments_url": "https://api.github.com/repos/test/test/issues/123/comments",
                "review_comments_url": "https://api.github.com/repos/test/test/pulls/123/comments",
            },
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        # Mock timeline, comments, reviews
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/issues/123/events",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/test/test/issues/123/comments",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/test/test/pulls/123/comments",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls/123/reviews",
            json=[],
        )

        # Initialize github_client
        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        # Call update_single_pr
        exit_code = gh_pr_metrics.update_single_pr(
            owner="testowner",
            repo="testrepo",
            pr_number=123,
            output_file=str(output_file),
            token="fake",
            config=default_config,
        )

        assert exit_code == 0

        # Read CSV and verify PR 123 was updated
        import csv

        with open(output_file, "r") as f:
            reader = csv.DictReader(f)
            rows = list(reader)

        # Should still have 2 PRs
        assert len(rows) == 2

        # Find PR 123
        pr_123 = next((r for r in rows if r["pr_number"] == "123"), None)
        assert pr_123 is not None
        assert pr_123["title"] == "Updated Title"
        assert pr_123["author"] == "newauthor"

        # PR 456 should be unchanged
        pr_456 = next((r for r in rows if r["pr_number"] == "456"), None)
        assert pr_456 is not None
        assert pr_456["title"] == "Another PR"

    def test_update_single_pr_adds_new_pr(self, requests_mock, tmp_path, default_config):
        """Test that update_single_pr adds a new PR if not in CSV."""
        output_file = tmp_path / "output.csv"

        # Create existing CSV with some data (without PR 789)
        output_file.write_text(
            "pr_number,title,author,created_at,ready_for_review_at,merged_at,closed_at,"
            "days_open,days_in_review,total_comment_count,non_ai_bot_comment_count,"
            "ai_bot_comment_count,non_ai_bot_login_names,ai_bot_login_names,"
            "changes_requested_count,unique_change_requesters,approval_count,status,url,errors\n"
            "123,Old Title,oldauthor,2024-01-01T00:00:00Z,2024-01-01T00:00:00Z,,,"
            "5.0,5.0,2,2,0,user1,,0,0,0,open,https://github.com/test/test/pull/123,\n"
        )

        # Mock PR fetch for new PR
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls/789",
            json={
                "number": 789,
                "title": "New PR",
                "user": {"login": "newauthor"},
                "created_at": "2024-01-03T00:00:00Z",
                "updated_at": "2024-01-03T00:00:00Z",
                "draft": False,
                "state": "open",
                "merged_at": None,
                "closed_at": None,
                "html_url": "https://github.com/test/test/pull/789",
                "comments_url": "https://api.github.com/repos/test/test/issues/789/comments",
                "review_comments_url": "https://api.github.com/repos/test/test/pulls/789/comments",
            },
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        # Mock timeline, comments, reviews
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/issues/789/events",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/test/test/issues/789/comments",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/test/test/pulls/789/comments",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls/789/reviews",
            json=[],
        )

        # Initialize github_client
        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        # Call update_single_pr
        exit_code = gh_pr_metrics.update_single_pr(
            owner="testowner",
            repo="testrepo",
            pr_number=789,
            output_file=str(output_file),
            token="fake",
            config=default_config,
        )

        assert exit_code == 0

        # Read CSV and verify PR 789 was added
        import csv

        with open(output_file, "r") as f:
            reader = csv.DictReader(f)
            rows = list(reader)

        # Should now have 2 PRs
        assert len(rows) == 2

        # Find PR 789
        pr_789 = next((r for r in rows if r["pr_number"] == "789"), None)
        assert pr_789 is not None
        assert pr_789["title"] == "New PR"
        assert pr_789["author"] == "newauthor"

    def test_update_single_pr_fails_if_csv_missing(self, default_config):
        """Test that update_single_pr fails if CSV doesn't exist."""
        # Initialize github_client
        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        exit_code = gh_pr_metrics.update_single_pr(
            owner="testowner",
            repo="testrepo",
            pr_number=123,
            output_file="/nonexistent/path/output.csv",
            token="fake",
            config=default_config,
        )

        assert exit_code == 1

    def test_update_single_pr_fails_on_api_error(self, requests_mock, tmp_path, default_config):
        """Test that update_single_pr fails gracefully on API error."""
        output_file = tmp_path / "output.csv"

        # Create existing CSV
        output_file.write_text(
            "pr_number,title,author,created_at,ready_for_review_at,merged_at,closed_at,"
            "days_open,days_in_review,total_comment_count,non_ai_bot_comment_count,"
            "ai_bot_comment_count,non_ai_bot_login_names,ai_bot_login_names,"
            "changes_requested_count,unique_change_requesters,approval_count,status,url,errors\n"
            "123,Old Title,oldauthor,2024-01-01T00:00:00Z,2024-01-01T00:00:00Z,,,"
            "5.0,5.0,2,2,0,user1,,0,0,0,open,https://github.com/test/test/pull/123,\n"
        )

        # Mock PR fetch to fail
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls/999",
            status_code=404,
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        # Initialize github_client
        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        exit_code = gh_pr_metrics.update_single_pr(
            owner="testowner",
            repo="testrepo",
            pr_number=999,
            output_file=str(output_file),
            token="fake",
            config=default_config,
        )

        assert exit_code == 1
