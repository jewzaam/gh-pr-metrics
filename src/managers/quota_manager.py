#!/usr/bin/env python3
# Generated By: Cursor (Claude Sonnet 4.5)
"""
Quota Management Module

Manages GitHub API quota tracking and enforcement.
Thread-safe for concurrent access.
"""

import logging
import threading
import requests
from datetime import datetime, timezone
from typing import Optional, Dict, Any


# Constants from github_api.py
GITHUB_API_BASE = "https://api.github.com"
API_CALLS_PER_PR = 4  # Estimate: timeline events, reviews, comments, review comments
API_SAFETY_BUFFER = 10  # Reserve for safety (unauthenticated limit is 60/hour total)
API_QUOTA_RESERVE_PCT = 0.05  # Reserve 5% of total quota, don't exhaust completely


class QuotaManager:
    """
    Manages GitHub API quota tracking and enforcement.

    Tracks quota from response headers, provides quota checking,
    and supports waiting for quota reset.
    """

    def __init__(self):
        """Initialize quota manager with zero quota."""
        self._remaining = 0
        self._limit = 0
        self._reset = 0  # Unix timestamp when quota resets
        self._lock = threading.Lock()
        self._logger = logging.getLogger(__name__)

    def get_quota_prefix(self) -> str:
        """Get quota prefix for logging (thread-safe)."""
        with self._lock:
            if self._limit == 0:
                return "[API ----/----]"

            # Left-pad remaining to match length of limit
            limit_str = str(self._limit)
            remaining_str = str(self._remaining).rjust(len(limit_str))
            return f"[API {remaining_str}/{limit_str}]"

    def update_from_headers(self, headers: dict) -> None:
        """Update quota tracking from API response headers (thread-safe)."""
        remaining = headers.get("X-RateLimit-Remaining")
        limit = headers.get("X-RateLimit-Limit")
        reset = headers.get("X-RateLimit-Reset")

        with self._lock:
            if remaining is not None:
                self._remaining = int(remaining)
            if limit is not None:
                self._limit = int(limit)
            if reset is not None:
                self._reset = int(reset)

    def get_current_quota(self) -> tuple[int, int, int]:
        """Get current quota (thread-safe). Returns (remaining, limit, reset)."""
        with self._lock:
            return self._remaining, self._limit, self._reset

    def initialize(self, token: Optional[str] = None) -> Dict[str, Any]:
        """
        Initialize quota by calling /rate_limit API.
        Returns dict with 'remaining', 'limit', 'reset' keys.
        """
        headers = {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
        }
        if token:
            headers["Authorization"] = f"Bearer {token}"

        try:
            response = requests.get(f"{GITHUB_API_BASE}/rate_limit", headers=headers, timeout=10)
            response.raise_for_status()
            data = response.json()

            core = data.get("resources", {}).get("core", {})
            remaining = core.get("remaining", 0)
            limit = core.get("limit", 0)
            reset = core.get("reset", 0)

            # Update tracking (thread-safe)
            with self._lock:
                self._remaining = remaining
                self._limit = limit
                self._reset = reset

            return {
                "remaining": remaining,
                "limit": limit,
                "reset": reset,
            }
        except Exception as e:
            self._logger.debug("Could not check rate limit: %s", e)
            return {}

    def calculate_max_prs(self) -> int:
        """
        Calculate maximum number of PRs processable with current quota.
        Reserves % of total quota to avoid complete exhaustion.
        """
        remaining, limit, _ = self.get_current_quota()

        if limit == 0:
            return 100  # Not initialized yet, conservative default

        # Reserve 5% of total quota (don't exhaust completely)
        reserve = int(limit * API_QUOTA_RESERVE_PCT)
        effective_buffer = max(API_SAFETY_BUFFER, reserve)

        available_for_prs = max(0, remaining - effective_buffer)
        max_prs = available_for_prs // API_CALLS_PER_PR

        return max_prs

    def wait_for_reset(self, logger=None) -> bool:
        """
        Wait until API quota resets.
        Returns True if successfully waited.
        """
        import time

        log = logger or self._logger
        remaining, limit, reset_timestamp = self.get_current_quota()

        # Add buffer for safety
        reset_timestamp = reset_timestamp + 15

        if reset_timestamp == 0:
            log.error("Cannot determine quota reset time (not initialized)")
            return False

        reset_time = datetime.fromtimestamp(reset_timestamp, tz=timezone.utc)
        now = datetime.now(timezone.utc)
        wait_seconds = (reset_time - now).total_seconds()

        if wait_seconds <= 0:
            log.info("Quota already reset, refreshing...")
            return True

        wait_minutes = wait_seconds / 60
        log.info(f"Waiting {wait_minutes:.1f} minutes for quota reset...")
        log.info(f"Will resume at {reset_time.strftime('%Y-%m-%d %H:%M:%S UTC')}")

        time.sleep(wait_seconds)

        log.info("Quota reset complete, refreshing quota like startup...")
        return True

    def check_sufficient(
        self,
        estimated_calls: int,
        repo_ctx: str,
        chunk_info: str = "",
        token_getter=None,
        logger=None,
    ) -> tuple[bool, int]:
        """
        Check if sufficient API rate limit available for estimated calls.
        Does NOT make an API call - uses current quota.

        Returns (sufficient, max_prs_possible).
        repo_ctx: Context string like "[owner/repo]" for logging
        chunk_info: Optional string like "Chunk 1: " for context
        token_getter: Optional function to get GitHub token
        """
        log = logger or self._logger

        # Use current quota (no API call unless not initialized)
        remaining, limit, _ = self.get_current_quota()

        if limit == 0:
            # Quota not initialized yet - initialize it now (one-time API call)
            log.warning("[%s] Quota not initialized, fetching current status", repo_ctx)
            token = token_getter() if token_getter else None
            rate_info = self.initialize(token)
            if not rate_info:
                # Failed to get quota - cannot proceed safely
                log.error("[%s] Failed to fetch quota, cannot verify rate limit", repo_ctx)
                return False, 0
            remaining = rate_info["remaining"]
            limit = rate_info["limit"]

        # Calculate max PRs we can handle
        max_prs = self.calculate_max_prs()

        # Calculate effective buffer (5% of total or fixed buffer, whichever is larger)
        reserve = int(limit * API_QUOTA_RESERVE_PCT)
        effective_buffer = max(API_SAFETY_BUFFER, reserve)

        # Show estimated calls for this operation
        log.info("[%s] %sEstimated API calls: ~%d", repo_ctx, chunk_info, estimated_calls)

        if remaining <= (estimated_calls + effective_buffer):
            log.error(
                "[%s] %sInsufficient API rate limit: need ~%d calls + %d buffer "
                "(reserve=%d), only %d available",
                repo_ctx,
                chunk_info,
                estimated_calls,
                effective_buffer,
                reserve,
                remaining,
            )
            log.warning(
                "[%s] %sCurrent quota allows processing ~%d PRs max", repo_ctx, chunk_info, max_prs
            )
            return False, max_prs

        return True, max_prs
