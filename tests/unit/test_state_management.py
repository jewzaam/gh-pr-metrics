# Generated By: Cursor (Claude Sonnet 4.5)
"""Tests for state file management."""

from datetime import datetime, timezone
from unittest import mock

import gh_pr_metrics

# from gh_pr_metrics import process_repository  # OLD - function removed in refactor


class TestStateManagement:
    """Test state file management for differential updates."""

    def test_load_state_file_nonexistent(self, tmp_path):
        """Test loading state file that doesn't exist returns empty dict."""
        state_file = tmp_path / "nonexistent.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            state = gh_pr_metrics.state_manager.load()
            assert state == {}

    def test_load_state_file_existing(self, tmp_path):
        """Test loading existing state file."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner/repo:\n  csv_file: metrics.csv\n"
            "  timestamp: '2024-01-01T00:00:00'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            state = gh_pr_metrics.state_manager.load()
            assert "https://github.com/owner/repo" in state
            assert state["https://github.com/owner/repo"]["timestamp"] == "2024-01-01T00:00:00"
            assert state["https://github.com/owner/repo"]["csv_file"] == "metrics.csv"

    def test_save_state_file(self, tmp_path):
        """Test saving state file."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            state = {
                "https://github.com/owner/repo": {
                    "timestamp": "2024-01-01T00:00:00",
                    "csv_file": "metrics.csv",
                }
            }
            gh_pr_metrics.state_manager.save(state)

            assert state_file.exists()
            content = state_file.read_text()
            assert "https://github.com/owner/repo" in content
            assert "2024-01-01T00:00:00" in content
            assert "metrics.csv" in content

    def test_update_state_file(self, tmp_path):
        """Test updating state file with new timestamp."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            timestamp = datetime(2024, 1, 15, 12, 0, 0, tzinfo=timezone.utc)
            gh_pr_metrics.state_manager.update_repo("owner", "repo", timestamp, "metrics.csv")

            # Verify state was saved (without timezone component)
            state = gh_pr_metrics.state_manager.load()
            repo_key = "https://github.com/owner/repo"
            assert repo_key in state
            assert "2024-01-15T12:00:00" == state[repo_key]["timestamp"]
            assert "metrics.csv" == state[repo_key]["csv_file"]

    def test_update_state_file_multiple_repos(self, tmp_path):
        """Test state file can track multiple repositories."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            # Add first repo
            timestamp1 = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
            gh_pr_metrics.state_manager.update_repo("owner1", "repo1", timestamp1, "repo1.csv")

            # Add second repo
            timestamp2 = datetime(2024, 1, 2, 0, 0, 0, tzinfo=timezone.utc)
            gh_pr_metrics.state_manager.update_repo("owner2", "repo2", timestamp2, "repo2.csv")

            # Verify both are in state
            state = gh_pr_metrics.state_manager.load()
            assert "https://github.com/owner1/repo1" in state
            assert "https://github.com/owner2/repo2" in state
            assert state["https://github.com/owner1/repo1"]["csv_file"] == "repo1.csv"
            assert state["https://github.com/owner2/repo2"]["csv_file"] == "repo2.csv"

    def test_update_state_file_overwrites_existing(self, tmp_path):
        """Test updating state file overwrites previous timestamp."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            # First update
            timestamp1 = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
            gh_pr_metrics.state_manager.update_repo("owner", "repo", timestamp1, "old.csv")

            # Second update (overwrites)
            timestamp2 = datetime(2024, 1, 15, 0, 0, 0, tzinfo=timezone.utc)
            gh_pr_metrics.state_manager.update_repo("owner", "repo", timestamp2, "new.csv")

            # Verify only latest timestamp and file are stored
            state = gh_pr_metrics.state_manager.load()
            repo_key = "https://github.com/owner/repo"
            assert repo_key in state
            assert "2024-01-15T00:00:00" == state[repo_key]["timestamp"]
            assert "new.csv" == state[repo_key]["csv_file"]

    def test_get_all_tracked_repos_empty(self, tmp_path):
        """Test getting tracked repos when state file is empty."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            repos = gh_pr_metrics.state_manager.get_all_tracked_repos()
            assert repos == []

    def test_get_all_tracked_repos_single_repo(self, tmp_path):
        """Test getting tracked repos with single repository."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner/repo:\n  csv_file: metrics.csv\n"
            "  timestamp: '2024-01-01T00:00:00Z'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            repos = gh_pr_metrics.state_manager.get_all_tracked_repos()
            assert len(repos) == 1
            assert repos[0]["owner"] == "owner"
            assert repos[0]["repo"] == "repo"
            assert repos[0]["url"] == "https://github.com/owner/repo"
            assert repos[0]["csv_file"] == "metrics.csv"
            assert repos[0]["timestamp"].year == 2024

    def test_get_all_tracked_repos_multiple_repos(self, tmp_path):
        """Test getting tracked repos with multiple repositories."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner1/repo1:\n  csv_file: repo1.csv\n"
            "  timestamp: '2024-01-01T00:00:00Z'\n"
            "https://github.com/owner2/repo2:\n  csv_file: repo2.csv\n"
            "  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            repos = gh_pr_metrics.state_manager.get_all_tracked_repos()
            assert len(repos) == 2
            owners = [r["owner"] for r in repos]
            assert "owner1" in owners
            assert "owner2" in owners

    def test_get_all_tracked_repos_invalid_format(self, tmp_path):
        """Test getting tracked repos with invalid state format."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner/repo: invalid_string\n"
            "https://github.com/owner2/repo2:\n  csv_file: repo2.csv\n"
            "  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            repos = gh_pr_metrics.state_manager.get_all_tracked_repos()
            # Should only get the valid repo
            assert len(repos) == 1
            assert repos[0]["owner"] == "owner2"

    def test_get_all_tracked_repos_malformed_url(self, tmp_path):
        """Test getting tracked repos with malformed URLs."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "badurl:\n  csv_file: metrics.csv\n"
            "  timestamp: '2024-01-01T00:00:00Z'\n"
            "https://github.com/owner/repo:\n  csv_file: good.csv\n"
            "  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            repos = gh_pr_metrics.state_manager.get_all_tracked_repos()
            # Should only get the valid repo
            assert len(repos) == 1
            assert repos[0]["owner"] == "owner"

    def test_mark_pr_failed_new_repo(self, tmp_path):
        """Test marking a PR as failed for a repo not in state."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            gh_pr_metrics.state_manager.mark_pr_failed("owner", "repo", 123)

            state = gh_pr_metrics.state_manager.load()
            assert "https://github.com/owner/repo" in state
            assert "failed_prs" in state["https://github.com/owner/repo"]
            assert 123 in state["https://github.com/owner/repo"]["failed_prs"]

    def test_mark_pr_failed_existing_repo(self, tmp_path):
        """Test marking a PR as failed for a repo already in state."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner/repo:\n  csv_file: metrics.csv\n"
            "  timestamp: '2024-01-01T00:00:00'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            gh_pr_metrics.state_manager.mark_pr_failed("owner", "repo", 456)

            state = gh_pr_metrics.state_manager.load()
            assert "failed_prs" in state["https://github.com/owner/repo"]
            assert 456 in state["https://github.com/owner/repo"]["failed_prs"]
            # Original fields preserved
            assert state["https://github.com/owner/repo"]["csv_file"] == "metrics.csv"

    def test_mark_pr_failed_no_duplicates(self, tmp_path):
        """Test marking same PR as failed multiple times doesn't create duplicates."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            gh_pr_metrics.state_manager.mark_pr_failed("owner", "repo", 789)
            gh_pr_metrics.state_manager.mark_pr_failed("owner", "repo", 789)
            gh_pr_metrics.state_manager.mark_pr_failed("owner", "repo", 789)

            state = gh_pr_metrics.state_manager.load()
            failed_prs = state["https://github.com/owner/repo"]["failed_prs"]
            assert failed_prs.count(789) == 1

    def test_mark_pr_succeeded_removes_from_list(self, tmp_path):
        """Test marking a PR as succeeded removes it from failed list."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner/repo:\n"
            "  csv_file: metrics.csv\n"
            "  timestamp: '2024-01-01T00:00:00'\n"
            "  failed_prs:\n"
            "  - 111\n"
            "  - 222\n"
            "  - 333\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            gh_pr_metrics.state_manager.mark_pr_succeeded("owner", "repo", 222)

            state = gh_pr_metrics.state_manager.load()
            failed_prs = state["https://github.com/owner/repo"]["failed_prs"]
            assert 222 not in failed_prs
            assert 111 in failed_prs
            assert 333 in failed_prs

    def test_mark_pr_succeeded_nonexistent_pr(self, tmp_path):
        """Test marking non-failed PR as succeeded doesn't error."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text("https://github.com/owner/repo:\n" "  failed_prs:\n" "  - 111\n")

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            # Should not error
            gh_pr_metrics.state_manager.mark_pr_succeeded("owner", "repo", 999)

            state = gh_pr_metrics.state_manager.load()
            assert 111 in state["https://github.com/owner/repo"]["failed_prs"]

    def test_get_failed_prs_empty(self, tmp_path):
        """Test getting failed PRs when none exist."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            failed_prs = gh_pr_metrics.state_manager.get_failed_prs("owner", "repo")
            assert failed_prs == []

    def test_get_failed_prs_with_failures(self, tmp_path):
        """Test getting failed PRs when some exist."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner/repo:\n" "  failed_prs:\n" "  - 10\n" "  - 20\n" "  - 30\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            failed_prs = gh_pr_metrics.state_manager.get_failed_prs("owner", "repo")
            assert failed_prs == [10, 20, 30]

    def test_get_all_failed_prs_count_multiple_repos(self, tmp_path):
        """Test getting total count of failed PRs across all repos."""
        state_file = tmp_path / "state.yaml"
        state_file.write_text(
            "https://github.com/owner1/repo1:\n"
            "  failed_prs:\n"
            "  - 1\n"
            "  - 2\n"
            "https://github.com/owner2/repo2:\n"
            "  failed_prs:\n"
            "  - 3\n"
            "  - 4\n"
            "  - 5\n"
            "https://github.com/owner3/repo3:\n"
            "  timestamp: '2024-01-01T00:00:00'\n"
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            count = gh_pr_metrics.state_manager.get_all_failed_prs_count()
            assert count == 5  # 2 from repo1 + 3 from repo2 + 0 from repo3

    def test_mark_pr_failed_concurrent_updates(self, tmp_path):
        """Test that concurrent mark_pr_failed calls don't lose data due to race conditions."""
        from concurrent.futures import ThreadPoolExecutor, as_completed

        state_file = tmp_path / "state.yaml"

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            # Simulate 10 threads marking different PRs as failed concurrently
            pr_numbers = list(range(1, 21))

            def mark_failed(pr_num):
                gh_pr_metrics.state_manager.mark_pr_failed("owner", "repo", pr_num)

            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = [executor.submit(mark_failed, pr_num) for pr_num in pr_numbers]
                for future in as_completed(futures):
                    future.result()  # Wait for completion

            # Verify all 20 PRs were recorded (no lost updates)
            failed_prs = gh_pr_metrics.state_manager.get_failed_prs("owner", "repo")
            assert len(failed_prs) == 20
            assert set(failed_prs) == set(pr_numbers)
