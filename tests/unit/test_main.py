# Generated By: Cursor (Claude Sonnet 4.5)
"""Tests for main application flow."""

import sys
import tempfile
from pathlib import Path
from unittest import mock

import gh_pr_metrics


class TestMain:
    """Test main application entry point."""

    def test_main_returns_error_without_repo(self):
        """Test that main() returns error when repo cannot be determined."""
        with mock.patch.object(sys, "argv", ["gh-pr-metrics"]):
            with mock.patch("gh_pr_metrics.get_repo_from_git", return_value=(None, None)):
                result = gh_pr_metrics.main()
                assert result == 1

    def test_main_with_explicit_repo(self, requests_mock):
        """Test main with explicitly specified repo."""
        # Mock the GitHub API to return empty PRs list
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls",
            json=[],
        )

        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo"],
        ):
            result = gh_pr_metrics.main()
            assert result == 0

    def test_main_update_mode_requires_output(self):
        """Test that update mode requires --output flag."""
        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo", "--update"],
        ):
            with mock.patch(
                "gh_pr_metrics.get_repo_from_git", return_value=("testowner", "testrepo")
            ):
                result = gh_pr_metrics.main()
                assert result == 1

    def test_main_update_mode_with_existing_state(self, requests_mock, tmp_path):
        """Test update mode uses last update date from state file."""
        state_file = tmp_path / "state.yaml"
        output_file = tmp_path / "test.csv"

        # Create initial CSV
        output_file.write_text("pr_number,title\n")

        # Create state with stored CSV path
        state_file.write_text(
            f"https://github.com/testowner/testrepo:\n"
            f"  csv_file: {output_file}\n"
            f"  timestamp: '2024-01-01T00:00:00'\n"
        )

        # Mock the GitHub API to return empty PRs list
        requests_mock.get(
            "https://api.github.com/repos/testowner/testrepo/pulls",
            json=[],
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo", "--update"],
        ):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                result = gh_pr_metrics.main()
                assert result == 0

    def test_main_update_mode_without_existing_state(self, tmp_path):
        """Test update mode fails when no state exists."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(
            sys,
            "argv",
            ["gh-pr-metrics", "--owner", "testowner", "--repo", "testrepo", "--update"],
        ):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                result = gh_pr_metrics.main()
                assert result == 1  # Should fail - no state

    def test_main_update_all_no_tracked_repos(self, tmp_path):
        """Test --update-all fails when no repos are tracked."""
        state_file = tmp_path / "state.yaml"

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                result = gh_pr_metrics.main()
                assert result == 1

    def test_main_update_all_with_tracked_repos(self, requests_mock, tmp_path):
        """Test --update-all processes all tracked repositories."""
        state_file = tmp_path / "state.yaml"
        csv_file1 = tmp_path / "repo1.csv"
        csv_file2 = tmp_path / "repo2.csv"

        # Create initial CSV files
        csv_file1.write_text("pr_number,title\n")
        csv_file2.write_text("pr_number,title\n")

        # Create state with two repos
        state_file.write_text(
            f"https://github.com/owner1/repo1:\n"
            f"  csv_file: {csv_file1}\n"
            f"  timestamp: '2024-01-01T00:00:00Z'\n"
            f"https://github.com/owner2/repo2:\n"
            f"  csv_file: {csv_file2}\n"
            f"  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        # Mock GitHub API for both repos
        requests_mock.get(
            "https://api.github.com/repos/owner1/repo1/pulls",
            json=[],
        )
        requests_mock.get(
            "https://api.github.com/repos/owner2/repo2/pulls",
            json=[],
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                result = gh_pr_metrics.main()
                assert result == 0

    def test_main_update_all_with_partial_failure(self, requests_mock, tmp_path):
        """Test --update-all continues after individual repo failure."""
        state_file = tmp_path / "state.yaml"
        csv_file1 = tmp_path / "repo1.csv"
        csv_file2 = tmp_path / "repo2.csv"

        # Create initial CSV files
        csv_file1.write_text("pr_number,title\n")
        csv_file2.write_text("pr_number,title\n")

        # Create state with two repos
        state_file.write_text(
            f"https://github.com/owner1/repo1:\n"
            f"  csv_file: {csv_file1}\n"
            f"  timestamp: '2024-01-01T00:00:00Z'\n"
            f"https://github.com/owner2/repo2:\n"
            f"  csv_file: {csv_file2}\n"
            f"  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        # Mock GitHub API - first fails, second succeeds
        requests_mock.get(
            "https://api.github.com/repos/owner1/repo1/pulls",
            status_code=404,
        )
        requests_mock.get(
            "https://api.github.com/repos/owner2/repo2/pulls",
            json=[],
        )

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                result = gh_pr_metrics.main()
                assert result == 1  # Returns failure due to partial failure

    def test_main_update_all_skips_repo_without_csv(self, tmp_path, requests_mock):
        """Test --update-all skips repos without CSV file in state."""
        state_file = tmp_path / "state.yaml"
        csv_file = tmp_path / "repo.csv"

        # Create initial CSV file for one repo
        csv_file.write_text("pr_number,title\n")

        # Create state with one repo missing csv_file
        state_file.write_text(
            "https://github.com/owner1/repo1:\n"
            "  timestamp: '2024-01-01T00:00:00Z'\n"
            f"https://github.com/owner2/repo2:\n"
            f"  csv_file: {csv_file}\n"
            f"  timestamp: '2024-01-02T00:00:00Z'\n"
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all"]):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                with mock.patch(
                    "gh_pr_metrics.process_repository", return_value=(0, 1, 1)
                ) as mock_process:
                    result = gh_pr_metrics.main()
                    # Should only process one repo
                    assert mock_process.call_count == 1
                    assert result == 0

    def test_main_update_all_restarts_from_beginning_with_wait(self, requests_mock):
        """Test that update-all with --wait restarts from beginning when repo fails."""
        state_file = Path(tempfile.mkdtemp()) / "state.yaml"

        # State with one repo
        state_file.write_text(
            "https://github.com/testowner/repo1:\n"
            "  timestamp: '2024-01-01T00:00:00'\n"
            "  csv_file: test.csv\n"
        )

        # Mock rate limit
        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        call_count = 0

        def process_side_effect(*args, **kwargs):
            nonlocal call_count
            call_count += 1
            return (0, 1, 1) if call_count == 2 else (1, 0, 0)  # Fail first, succeed second

        with mock.patch.object(sys, "argv", ["gh-pr-metrics", "--update-all", "--wait"]):
            with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                with mock.patch("gh_pr_metrics.process_repository") as mock_process:
                    with mock.patch.object(
                        gh_pr_metrics.quota_manager, "wait_for_reset", return_value=True
                    ):
                        mock_process.side_effect = process_side_effect
                        result = gh_pr_metrics.main()

                # Should call process_repository twice (fail, wait, retry same repo)
                assert mock_process.call_count == 2
                # Both calls for same repo (restart from beginning)
                assert mock_process.call_args_list[0][0][0] == "testowner"
                assert mock_process.call_args_list[0][0][1] == "repo1"
                assert mock_process.call_args_list[1][0][0] == "testowner"
                assert mock_process.call_args_list[1][0][1] == "repo1"
                assert result == 0  # Success on retry


class TestProcessRepository:
    """Test process_repository function behavior."""

    def test_returns_error_when_quota_exhausted_mid_processing(self, tmp_path, requests_mock):
        """Test that process_repository returns error code when quota exhausted."""
        state_file = tmp_path / "state.yaml"
        output_file = tmp_path / "output.csv"

        from datetime import datetime, timezone

        start_date = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2024, 1, 31, 0, 0, 0, tzinfo=timezone.utc)

        # Initialize github_client
        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        # Mock fetch_all_prs to return many PRs
        with mock.patch.object(
            gh_pr_metrics.github_client,
            "fetch_all_prs",
            return_value=[
                {
                    "number": i,
                    "title": f"PR {i}",
                    "updated_at": "2024-01-15T00:00:00Z",
                    "created_at": "2024-01-01T00:00:00Z",
                    "state": "open",
                    "user": {"login": "test"},
                    "html_url": f"https://github.com/test/test/pull/{i}",
                    "draft": False,
                    "comments_url": f"https://api.github.com/repos/test/test/issues/{i}/comments",
                    "review_comments_url": (
                        f"https://api.github.com/repos/test/test/pulls/{i}/comments"
                    ),
                }
                for i in range(200)  # 200 PRs = 2 chunks
            ],
        ):
            # Mock quota check to fail on second chunk
            call_count = 0

            def mock_check_sufficient(estimated_calls, repo_ctx, chunk_info=""):
                nonlocal call_count
                call_count += 1
                if call_count == 1:
                    return True, 50  # First chunk: sufficient
                else:
                    return False, 0  # Second chunk: exhausted

            with mock.patch.object(
                gh_pr_metrics.quota_manager, "check_sufficient", side_effect=mock_check_sufficient
            ):
                with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
                    # Mock process_pr to succeed quickly
                    with mock.patch(
                        "gh_pr_metrics.process_pr", return_value={"pr_number": 1, "title": "test"}
                    ):
                        exit_code, chunks_completed, total_chunks = (
                            gh_pr_metrics.process_repository(
                                owner="test",
                                repo="test",
                                output_file=str(output_file),
                                start_date=start_date,
                                end_date=end_date,
                                token="fake",
                                workers=1,
                                ai_bot_regex="",
                                merge_mode=False,
                            )
                        )

        # Should return error code when stopping due to quota
        assert exit_code == 1
        assert chunks_completed == 1  # Only completed first chunk
        assert total_chunks == 2  # Expected 2 chunks total

    def test_no_csv_created_when_no_prs(self, tmp_path, requests_mock):
        """Test that process_repository does not create CSV when no PRs found."""
        state_file = tmp_path / "state.yaml"
        output_file = tmp_path / "output.csv"

        from datetime import datetime, timezone

        start_date = datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
        end_date = datetime(2024, 1, 31, 0, 0, 0, tzinfo=timezone.utc)

        # Mock empty PR list
        requests_mock.get("https://api.github.com/repos/test/test/pulls", json=[])

        requests_mock.get(
            "https://api.github.com/rate_limit",
            json={"resources": {"core": {"limit": 5000, "remaining": 4999, "reset": 1699999999}}},
        )

        gh_pr_metrics.github_client = gh_pr_metrics.GitHubClient(
            "fake", gh_pr_metrics.quota_manager, gh_pr_metrics.logger
        )

        with mock.patch.object(gh_pr_metrics.state_manager, "_state_file", state_file):
            exit_code, chunks_completed, total_chunks = gh_pr_metrics.process_repository(
                owner="test",
                repo="test",
                output_file=str(output_file),
                start_date=start_date,
                end_date=end_date,
                token="fake",
                workers=1,
                ai_bot_regex="",
                merge_mode=False,
            )

            # Should succeed with no PRs
            assert exit_code == 0
            # CSV should NOT be created
            assert not output_file.exists()
            # State should be updated (check inside mock context)
            state = gh_pr_metrics.state_manager.load()
            assert "https://github.com/test/test" in state
